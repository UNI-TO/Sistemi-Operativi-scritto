{
  "id": "esame-teoria-27-gennaio-2026",
  "date": "2026.01.27",
  "course": "Teoria",
  "title": "Scritto parte di teoria del corso A di Sistemi Operativi del 27 gennaio 2026",
  "topics": [
    "file-system",
    "memoria-primaria",
    "processi-scheduling",
    "sincronizzazione",
    "memoria-massa"
  ],
  "questions": [
    {
      "number": 1,
      "text": "Un hard disk ha la dimensione di 512 Gigabyte, è formattato in blocchi da 0x1000 byte e adotta una allocazione concatenata (senza FAT) dello spazio su disco. Sull'hard disk è memorizzato un file A della dimensione di 0x4000 byte. Quanti byte del file sono memorizzati nell'ultimo blocco di dati del file? (selezionate l'opzione di risposta che riporta il calcolo corretto del valore cercato)",
      "answer": "La risposta corretta è: 2^39/2^12 = 2^27 ==> 4 byte per scrivere un puntatore a blocco. Dunque, l'ultimo blocco di A conterrà 4 * 2^14/2^12 = 16 byte di A",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "2^39/2^15 = 2^24 ==> 3 byte per scrivere un puntatore a blocco. Dunque, l'ultimo blocco di A conterrà 3 * 2^15/2^13 = 12 byte di A",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "2^39/2^12 = 2^27 ==> 4 byte per scrivere un puntatore a blocco. Dunque, l'ultimo blocco di A conterrà 4 * 2^14/2^12 = 16 byte di A",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "2^39/2^12 = 2^27 ==> 4 byte per scrivere un puntatore a blocco. Dunque, l'ultimo blocco di A conterrà 2^14/4 = 4096 byte di A",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "2^39/2^13 = 2^26 ==> 4 byte per scrivere un puntatore a blocco. Dunque, l'ultimo blocco di A conterrà 2^15/4 = 8192 byte di A",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    },
    {
      "number": 2,
      "text": "In un sistema che adotta la paginazione della memoria, un indirizzo logico è scritto su \"M\" bit, e il numero di pagina è scritto su \"l\" bit. Lo spazio fisico è invece suddiviso in 2^32 frame. Possiamo quindi dire che: un frame del sistema è grande [ ], lo spazio fisico del sistema è grande [ ], la tabella delle pagine più grande del sistema ha una dimensione di [ ], il sistema dovrà implementare la memoria virtuale solo se [ ]",
      "answer": "La risposta corretta è: un frame del sistema è grande [2^(M-l)] byte, lo spazio fisico del sistema è grande [2^(32+M-l)] byte, la tabella delle pagine più grande del sistema ha una dimensione di [(2^l) * 4] byte, il sistema dovrà implementare la memoria virtuale solo se [M > (32+M-l)]",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multianswer",
      "statements": [
        {
          "text": "un frame del sistema è grande: 2^(M-l) byte",
          "isCorrect": true
        },
        {
          "text": "lo spazio fisico del sistema è grande: 2^(32+M-l) byte",
          "isCorrect": true
        },
        {
          "text": "la tabella delle pagine più grande del sistema ha una dimensione di: 2^(32-M+l) byte",
          "isCorrect": false
        },
        {
          "text": "il sistema dovrà implementare la memoria virtuale solo se: M > (32+M-l)",
          "isCorrect": true
        }
      ]
    },
    {
      "number": 3,
      "text": "Dopo l'esecuzione dei seguenti comandi in un ambiente Unix (come visti a lezione): 1: cd /tmp, 2: mkdir newfolder, 3: cd newfolder, 4: echo \"ciao\" > pippo // crea un nuovo file di nome pippo contenente la stringa ciao, 5: ln pippo paperino, 6: ln ../newfolder folder2, 7: cp paperino topolino, 8: echo \"salve\" >> topolino // aggiunge \"salve\" a fondo file, 9: cat paperino // cat stampa il contenuto del file passato come argomento, 10: cat topolino, 11: rmdir ../folder3. Scegli un'alternativa:",
      "answer": "La risposta corretta è: 1. il link-counter dell'i-node di paperino è: 1, 2. il link counter di tmp è: aumentato di 2, 3. l'output del comando 10 è: \"ciao\", 4. il comando 6 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di tmp è: 2, 3. l'output del comando 10 è: \"ciao\", 4. il comando 6 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di tmp è: aumentato di 2, 3. l'output del comando 10 è: \"ciao\" seguito da \"salve\", 4. il comando 6 dà come risultato: un nuovo collegamento alla cartella newfolder",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "1. il link-counter dell'i-node di paperino è: 1, 2. il link counter di tmp è: aumentato di 2, 3. l'output del comando 10 è: \"ciao\", 4. il comando 6 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
          "isCorrect": true
        },
        {
          "id": "d",
          "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di tmp è: 1, 3. l'output del comando 10 è: \"ciao\" seguito da \"salve\", 4. il comando 6 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
          "isCorrect": false
        }
      ],
      "correctAnswer": "c"
    },
    {
      "number": 4,
      "text": "Degli algoritmi di sostituzione delle pagine possiamo dire che (scegliete l'unica opzione completamente corretta):",
      "answer": "La risposta corretta è: LRU è uno dei migliori algoritmi di rimpiazzamento, ma non viene implementato perché richiederebbe un supporto hardware normalmente non disponibile",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "LRU è uno dei migliori algoritmi di rimpiazzamento, ma non viene implementato perché richiederebbe un supporto hardware normalmente non disponibile",
          "isCorrect": true
        },
        {
          "id": "b",
          "text": "l'algoritmo della seconda chance migliorata è chiamato così perché, al contrario dell'algoritmo della seconda chance, non soffre dell'anomalia di Belady",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "l'algoritmo di sostituzione ottimale (detto OPT o MIN) è detto così perché sceglie come pagina vittima di un processo quella che non verrà mai più indirizzata dal processo stesso",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "l'algoritmo della seconda chance è una approssimazione di LRU implementata usando il dirty bit per distinguere le pagine modificate da quelle non modificate",
          "isCorrect": false
        }
      ],
      "correctAnswer": "a"
    },
    {
      "number": 5,
      "text": "Un hard disk ha la dimensione di 512 Gigabyte, è formattato in blocchi da 0x400 byte e adotta una qualche forma di allocazione indicizzata dello spazio su disco. Sull'hard disk è memorizzato un file A della dimensione di 600 Kbyte. Quante operazioni di I/O sono necessarie per leggere l'ultimo blocco di dati del file, assumendo già in RAM tutti gli attributi del file, incluso il numero del primo blocco indice, e assumendo uno schema di allocazione indicizzata concatenato (a livello zero)?",
      "answer": "La risposta corretta è: 2^39/2^10 = 2^29, dunque un blocco indice di questo hard disk può tenere traccia di un massimo di 256 Kbyte di dati. Assumendo una allocazione indicizzata a schema concatenato, ci vogliamo 3 blocchi indice per rappresentare l'ultimo blocco di dati del file, e dunque, se è già in RAM il numero del primo blocco indice, saranno necessarie in tutto 4 operazioni di lettura su disco",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "2^39/2^10 = 2^29, dunque un blocco indice di questo hard disk può tenere traccia di un massimo di 256 Kbyte di dati. Assumendo una allocazione indicizzata a schema concatenato, ci vogliamo 2 blocchi indice per rappresentare l'ultimo blocco di dati del file, e dunque, se è già in RAM il numero del primo blocco indice, saremo necessarie in tutto 3 operazioni di lettura su disco",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "2^39/2^11 = 2^28, dunque un blocco indice di questo hard disk può tenere traccia di un massimo di 512 Kbyte di dati. Assumendo una allocazione indicizzata a più livelli, ci vogliamo 2 blocchi indice e 1 blocco dati per rappresentare l'ultimo blocco di dati del file, e dunque, se è già in RAM il numero del primo blocco indice, saremo necessarie in tutto 4 operazioni di lettura su disco",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "2^39/2^10 = 2^29, dunque un blocco indice di questo hard disk può tenere traccia di un massimo di 256 Kbyte di dati. Assumendo una allocazione indicizzata a schema concatenato, ci vogliamo 3 blocchi indice per rappresentare l'ultimo blocco di dati del file, e dunque, se è già in RAM il numero del primo blocco indice, saremo necessarie in tutto 4 operazioni di lettura su disco",
          "isCorrect": true
        },
        {
          "id": "d",
          "text": "2^39/2^11 = 2^28, dunque un blocco indice di questo hard disk può tenere traccia di un massimo di 512 Kbyte di dati. Assumendo una allocazione indicizzata a schema concatenato, ci vogliamo 2 blocchi indice per rappresentare l'ultimo blocco di dati del file, e dunque, se è già in RAM il numero del primo blocco indice, saremo necessarie in tutto 3 operazioni di lettura su disco",
          "isCorrect": false
        }
      ],
      "correctAnswer": "c"
    },
    {
      "number": 6,
      "text": "Si consideri l'esecuzione della seguente porzione di codice che utilizza la system call fork: int a, b, c, d, n, pid1, pid2, pid3; a=30, b= 4, c=50, d= 60; n= fork(); if ( n== 0) {a = 35; b = 45; pid1 = getppid(); printf(\"%d\", pid1); exit(0);} else {c = 55; d = 65; pid2 = getpid(); printf(\"%d\",pid2); pid3 = wait(...); exit(0);}. Determinare i valori delle variabili e l'ordine di esecuzione delle stampe.",
      "answer": "La risposta corretta è: il valore della variabile a visto dal processo figlio subito prima della sua exit è [35], il valore della variabile c visto dal processo figlio subito prima della sua exit è [50], il valore della variabile a visto dal processo padre subito prima della sua exit è [30], il valore della variabile b visto dal processo padre subito prima della sua exit è [4], all'esecuzione delle due printf vale la seguente relazione: pid1 [=] pid2, del risultato della wait possiamo dire che: pid3 [=] pid2",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multianswer",
      "statements": [
        {
          "text": "il valore della variabile a visto dal processo figlio subito prima della sua exit è 35",
          "isCorrect": true
        },
        {
          "text": "il valore della variabile c visto dal processo figlio subito prima della sua exit è 50",
          "isCorrect": true
        },
        {
          "text": "il valore della variabile a visto dal processo padre subito prima della sua exit è 30",
          "isCorrect": true
        },
        {
          "text": "il valore della variabile b visto dal processo padre subito prima della sua exit è 4",
          "isCorrect": true
        },
        {
          "text": "all'esecuzione delle due printf vale la seguente relazione: pid1 = pid2",
          "isCorrect": true
        },
        {
          "text": "del risultato della wait possiamo dire che: pid3 = padre",
          "isCorrect": false
        }
      ]
    },
    {
      "number": 7,
      "text": "Sia A un file di testo all'interno di un file system Unix. Viene eseguito con successo il comando: ln A B dove B non esisteva prima dell'esecuzione del comando. Che cosa succede nelle strutture interne al sistema?",
      "answer": "La risposta corretta è: Una nuova entry di nome B viene inserita nella cartella in cui è stato eseguito il comando. Il numero dell'i-node associato ad A viene ora associato anche a B. Il link counter di quell'i-node viene incrementato di 1",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "nella cartella in cui viene eseguito il comando viene creato un nuovo file di nome B, e il link counter dell'i-node associato ad A viene inizializzato a 1. Il link counter dell'i-node associato ad A viene incrementato di 1",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "Una nuova entry di nome B viene inserita nella cartella in cui è stato eseguito il comando, e un nuovo i-node viene associato a B. Il path name di A viene scritto dentro l'i-node associato a B. Il link counter dell'i-node associato a B viene inizializzato a 1",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "il contenuto di A viene copiato dentro a B. L'i-node di A viene duplicato e associato a B. Il link counter dell'i-node associato a B viene inizializzato a 1, mentre il link counter dell'i-node associato ad A viene incrementato di 1",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "Una nuova entry di nome B viene inserita nella cartella in cui è stato eseguito il comando. Il numero dell'i-node associato ad A viene ora associato anche a B. Il link counter di quell'i-node viene incrementato di 1",
          "isCorrect": true
        }
      ],
      "correctAnswer": "d"
    },
    {
      "number": 8,
      "text": "In un sistema operativo che adotta uno scheduling con diritto di prelazione, quattro processi arrivano al tempo indicato e consumano la quantità di CPU indicata nella tabella sottostante: ProcessoT. di arrivoT.di burst| Pa | 0 | 8, Pb | 2 | 8, Pc | 4 | 2, Pd | 6 | 1. Qual è il waiting time medio ottenuto per lo scheduling dei quattro processi della tabella se si usa l'algoritmo di scheduling preemptive che fornisce il miglior turnaround time possibile? Qual è il corrispondente diagramma di GANTT?",
      "answer": "La risposta corretta è: Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pa ... (11) ... Pb ... (19). Waiting time medio = 3",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pb ... (7) ... Pd ... (9) ... Pa ... (11) ... Pc ... (19). Waiting time medio = 3",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pb ... (7) ... Pc ... (10) ... Pa ... (11) ... Pd ... (19). Waiting time medio = 4",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pa ... (10) ... Pd ... (11) ... Pc ... (19). Waiting time medio = 4",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pa ... (11) ... Pb ... (19). Waiting time medio = 3",
          "isCorrect": true
        }
      ],
      "correctAnswer": "d"
    },
    {
      "number": 9,
      "text": "In quale/i caso/i un processo in coda di ready può decidere di passare allo stato running?",
      "answer": "La risposta corretta è: mai, è il Sistema Operativo che sposta i processi da uno stato all'altro.",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "quando un processo si trova in testa alla coda di ready",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "in tutti gli algoritmi di scheduling non preemptive, dove un processo può decidere autonomamente quanto tempo passare in coda di ready",
          "isCorrect": false
        },
        {
          "id": "c",
          "text": "mai, è il Sistema Operativo che sposta i processi da uno stato all'altro.",
          "isCorrect": true
        },
        {
          "id": "d",
          "text": "quando un processo esce da un qualsiasi stato di waiting",
          "isCorrect": false
        }
      ],
      "correctAnswer": "c"
    },
    {
      "number": 10,
      "text": "Si deve configurare un sistema RAID sapendo che è importante avere a disposizione un ampio spazio di memorizzazione, mentre l'affidabilità del sistema non è importante. Quale livello RAID conviene scegliere?",
      "answer": "La risposta corretta è: il RAID di livello 0, in cui non si ha nessuna ridondanza dei dati e non si usano strip di parità, per cui in caso di guasto è impossibile recuperare i dati persi",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "il RAID di livello 1, in cui tutti i dischi del RAID sono usati per memorizzare strip di dati",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "il RAID di livello 0, in cui non si ha nessuna ridondanza dei dati e non si usano strip di parità, per cui in caso di guasto è impossibile recuperare i dati persi",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "il RAID di livello 4, in cui tutti i dischi del RAID potrebbero essere usati per memorizzare i dati, ad eccezione di un disco usato per gli strip di parità",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "il RAID di livello 01, in cui sono disponibili anche i dischi di mirroring per memorizzare gli strip di dati",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    },
    {
      "number": 11,
      "text": "In un sistema paginato è noto che lo spreco di memoria primaria dovuto alla frammentazione interna è in media di circa 4 Kbyte per processo, e un indirizzo logico è scritto su 32 bit. Se la tabella delle pagine più grande di questo sistema è grande 1024 Kilobyte, quanto può essere grande al massimo lo spazio di indirizzamento fisico del sistema?",
      "answer": "La risposta corretta è: 512 Megabyte",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "4 Gigabyte",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "512 Megabyte",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "2 Gigabyte",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "1 Gigabyte",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    },
    {
      "number": 12,
      "text": "Ricostruite il codice del generico lettore nel problema dei lettori-scrittori: semaphore mutex = 1, scrivi = 1; int numlettori= 0; Processo lettore { wait(mutex); [ ]; [ ]; signal(mutex); ... leggi il file ...; wait(mutex); [ ]; [ ]; signal(mutex) }",
      "answer": "La risposta corretta è: [numlettori++;] [if numlettori == 1 wait(scrivi);] [numlettori--;] [if numlettori == 0 signal(scrivi);]",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "essay"
    },
    {
      "number": 13,
      "text": "Un sistema ha un tempo di accesso in RAM di 120 ns, adotta un TLB con un tempo di accesso di 10 ns e un hit rate del 95%, usa una paginazione a due livelli e non ha bisogno di usare un algoritmo di rimpiazzamento delle pagine. Qual è il tempo medio di accesso alla RAM (medium access time - mat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB)",
      "answer": "La risposta corretta è: mat = 141,5 ns",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "mat = 147,5 ns",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "mat = 141,5 ns",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "mat = 130,5 ns",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "mat = 135,5 ns",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    },
    {
      "number": 14,
      "text": "Una Inverted Page Table può essere così descritta:",
      "answer": "La risposta corretta è: ha un numero di entry pari al numero di frame in cui è suddiviso lo spazio fisico del sistema, e ogni entry contiene la coppia \"PID-numero di pagina\". Ogni indirizzo logico è formato dalla tripla \"PID-numero di pagina-offset\". Per tradurre un indirizzo di logico a fisico si cerca la coppia \"PID-numero di pagina\" nelle entry della IPT. Se si trova la coppia alla entry F-esima, allora l'indirizzo fisico è costituito dalla coppia \"F-offset\"",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "ha un numero di entry pari al numero di pagine in cui è suddiviso lo spazio logico di un processo, e ogni entry contiene il numero di un frame. Ogni indirizzo logico è formato dalla tripla \"PID-numero di pagina-offset\". Per tradurre un indirizzo di logico a fisico si cerca la entry P alla posizione \"numero di pagina\", e l'indirizzo fisico è costituito dalla coppia \"P-offset\"",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "ha un numero di entry pari al numero di frame in cui è suddiviso lo spazio fisico del sistema, e ogni entry contiene la coppia \"PID-numero di pagina\". Ogni indirizzo logico è formato dalla tripla \"PID-numero di pagina-offset\". Per tradurre un indirizzo di logico a fisico si cerca la coppia \"PID-numero di pagina\" nelle entry della IPT. Se si trova la coppia alla entry F-esima, allora l'indirizzo fisico è costituito dalla coppia \"F-offset\"",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "ha un numero di entry pari al numero di frame in cui è suddiviso lo spazio fisico del processo in esecuzione, e ogni entry contiene il numero di una pagina. Per tradurre un indirizzo di logico a fisico si cerca alla entry F \"numero di frame\" della IPT, e se si trova la pagina P-esima, allora l'indirizzo fisico è costituito dalla coppia \"P-offset\"",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "ha un numero di entry pari al numero di pagine in cui è suddiviso lo spazio logico di un processo, e ogni entry contiene il numero di un frame. Ogni indirizzo logico è formato dalla coppia \"numero di pagina-offset\". Per tradurre un indirizzo di logico a fisico si cerca la entry F alla posizione \"numero di pagina\", e l'indirizzo fisico è costituito dalla coppia \"F-offset\"",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    },
    {
      "number": 15,
      "text": "Il diagramma di transizione degli stati di un processo visto a lezione descrive un sistema time-sharing. Come può essere modificato per descrivere invece un sistema multi-tasking ma non time-sharing?",
      "answer": "La risposta corretta è: basta rimuovere l'arco che porta dallo stato \"running\" allo stato \"ready to run\"",
      "maxPoints": 2,
      "negativePoints": 0,
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "basta rinominare l'arco che porta dallo stato \"ready to run\" allo stato \"running\"",
          "isCorrect": false
        },
        {
          "id": "b",
          "text": "basta rimuovere l'arco che porta dallo stato \"running\" allo stato \"ready to run\"",
          "isCorrect": true
        },
        {
          "id": "c",
          "text": "basta rimuovere l'arco che porta dallo stato \"waiting\" allo stato \"ready to run\"",
          "isCorrect": false
        },
        {
          "id": "d",
          "text": "basta rimuovere l'arco che porta dallo stato \"running\" allo stato \"waiting\"",
          "isCorrect": false
        }
      ],
      "correctAnswer": "b"
    }
  ]
}
