[
  {
    "id": "teoria-so-b-18-06-2025",
    "date": "2025.06.18",
    "course": "B",
    "title": "Teoria SO Corso B 18/06/2025",
    "topics": [
      "generalita",
      "processi-scheduling",
      "sincronizzazione",
      "memoria-primaria",
      "file-system"
    ],
    "questions": [
      {
        "number": 1,
        "text": "Quando si usa lo scheduling della CPU \"shortest remaining time first\", è possibile che un processo passato dallo stato WAITING allo stato READY ottenga subito la CPU tramite prelazione",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "Immagine 2025-06-18 113947.png"
      },
      {
        "number": 2,
        "text": "in generale i semafori non soffrono di starvation",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "Immagine 2025-06-18 113947.png"
      },
      {
        "number": 3,
        "text": "L'allocazione contigua della RAM ai processi è soggetta a frammentazione esterna",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "Immagine 2025-06-18 114035.png"
      },
      {
        "number": 4,
        "text": "Attesa circolare è una condizione sufficiente al deadlock",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "Immagine 2025-06-18 114035.png"
      },
      {
        "number": 5,
        "text": "Possesso e attesa è una condizione necessaria al deadlock",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "Immagine 2025-06-18 114052.png"
      },
      {
        "number": 6,
        "text": "I sistemi RAID rendono l'elaboratore più robusto rispetto a guasti inerenti la memoria",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "Immagine 2025-06-18 114052.png"
      },
      {
        "number": 7,
        "text": "Per CPU burst si intende un periodo di utilizzo ininterrotto della CPU da parte di un processo",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "Immagine 2025-06-18 114108.png"
      },
      {
        "number": 8,
        "text": "Indica se le seguenti affermazioni inerenti la memoria virtuale sono vere o false (vedi immagine)",
        "answer": "Risposte corrette: V-V-V-F-F (1. La memoria virtuale richiede la presenza di un algoritmo di sostituzione delle pagine, 2. La paginazione è alla base della memoria virtuale, 3. il numero di frame assegnati a ciascun processo dipende anche dall'architettura, 4. la memoria virtuale è impedita dalla rilocabilità, 5. la memoria virtuale richiede una gestione esplicita da parte dei programmatori dei sistemi che ne faranno uso)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "Immagine 2025-06-18 114108.png",
        "correctAnswers": [
          "V",
          "V",
          "V",
          "F",
          "F"
        ]
      },
      {
        "number": 9,
        "text": "Si associ a ciascuna affermazione (vedi immagine)",
        "answer": "Risposte corrette: F-V-F-V-V (1. i file system strutturati ad albero non fanno uso di link, 2. la cancellazione di un link simbolico ha un effetto diverso dalla cancellazione di un link fisico, 3. in un file system gerarchico ogni nodo ha un solo PATH relativo, 4. in un file system gerarchico ogni nodo ha un solo PATH assoluto, 5. i file system a grafo aciclico fanno uso di link)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "Immagine 2025-06-18 114123.png",
        "correctAnswers": [
          "F",
          "V",
          "F",
          "V",
          "V"
        ]
      },
      {
        "number": 10,
        "text": "Supponiamo che in un sistema in cui la pagina vittima è scelta con algoritmo di seconda chance, la lista delle pagine caricate (e relativi bit di riferimento) sia la seguente: p1 (1) → p2 (1) → p3 (0) → p4 (0) → p5 (1). Supponendo di partire da p1, quali sono la configurazione della lista e la vittima identificata, dopo la passata dell'algoritmo?",
        "answer": "Risposta corretta: p1 (0) → p2 (0) → p3 (VITTIMA) → p4 (0) → p5 (1)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "Immagine 2025-06-18 114136.png"
      },
      {
        "number": 11,
        "text": "(1) riportare la definizione di deadlock, includendo l'elenco e le definizioni delle condizioni necessarie al suo verificarsi, (2) descrivere e spiegare l'uso dei grafi di assegnazione delle risorse",
        "answer": "Risposta completa richiesta (max 5.00 punti)",
        "maxPoints": 5,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "Immagine 2025-06-18 114157.png"
      },
      {
        "number": 12,
        "text": "(1) spiegare il dual mode e cosa si intende per system call, (2) dire cos'è e come viene usato il vettore delle interruzioni",
        "answer": "Risposta completa richiesta (max 5.00 punti)",
        "maxPoints": 5,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "Immagine 2025-06-18 114213.png"
      }
    ]
  },
  {
    "id": "so-b-17-06-2025",
    "date": "2025.06.17",
    "course": "B",
    "title": "SO Corso B Appello 17/06/2025 - Teoria",
    "topics": [
      "generalita",
      "processi-scheduling",
      "sincronizzazione",
      "memoria-primaria",
      "file-system"
    ],
    "questions": [
      {
        "number": 1,
        "text": "in generale i semafori non soffrono di starvation",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "domanda 1-2.png"
      },
      {
        "number": 2,
        "text": "Il round robin è particolarmente adatto ai sistemi che attribuiscono priorità diverse ai processi",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "domanda 1-2.png"
      },
      {
        "number": 3,
        "text": "La separazione dello spazio degli indirizzi logico dallo spazio degli indirizzi fisico permette di implementare la rilocabilità del codice",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "domanda 3-4.png"
      },
      {
        "number": 4,
        "text": "La copiatura su scrittura è una strategia finalizzata a ridurre la quantità di frame di RAM allocata ai processi figli",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "domanda 3-4.png"
      },
      {
        "number": 5,
        "text": "Per CPU burst si intende un periodo di utilizzo ininterrotto della CPU da parte di un processo",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "domanda 5-6.png"
      },
      {
        "number": 6,
        "text": "Una delle strategie di Havender consiste nell'inibire la mutua esclusione nell'accesso alle risorse",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "domanda 5-6.png"
      },
      {
        "number": 7,
        "text": "I meccanismi adottati dai sistemi operativi per allocare memoria ai processi kernel è identico a quello adottato per i processi utente",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "domanda 7-8.png"
      },
      {
        "number": 8,
        "text": "Indica se le seguenti affermazioni inerenti la memoria virtuale sono vere o false (vedi immagine)",
        "answer": "Risposte corrette: V-F-V-F-V (1. La paginazione è alla base della memoria virtuale, 2. La memoria virtuale è impedita dalla rilocabilità, 3. La memoria virtuale richiede la presenza di un algoritmo di sostituzione delle pagine, 4. la memoria virtuale richiede una gestione esplicita da parte dei programmatori dei sistemi che ne faranno uso, 5. il numero di frame assegnati a ciascun processo dipende anche dall'architettura)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "domanda 7-8.png",
        "correctAnswers": [
          "V",
          "F",
          "V",
          "F",
          "V"
        ]
      },
      {
        "number": 9,
        "text": "Si associ a ciascuna affermazione (vedi immagine)",
        "answer": "Risposte corrette: V-F-V-V-V (1. i file system strutturati ad albero non fanno uso di link, 2. in un file system gerarchico ogni nodo ha un solo PATH relativo, 3. la cancellazione di un link simbolico ha un effetto diverso dalla cancellazione di un link fisico, 4. in un file system gerarchico ogni nodo ha un solo PATH assoluto, 5. i file system a grafo aciclico fanno uso di link)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "domanda 9.png",
        "correctAnswers": [
          "V",
          "F",
          "V",
          "V",
          "V"
        ]
      },
      {
        "number": 10,
        "text": "Supponiamo che in un sistema in cui la pagina vittima è scelta con algoritmo di seconda chance, la lista delle pagine caricate (e relativi bit di riferimento) sia la seguente: p1 (1) → p2 (1) → p3 (0) → p4 (0) → p5 (1). Supponendo di partire da p1, quali sono la configurazione della lista e la vittima identificata, dopo la passata dell'algoritmo?",
        "answer": "Risposta corretta: p1 (0) → p2 (0) → p3 (VITTIMA) → p4 (0) → p5 (1)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "domanda 10.png"
      },
      {
        "number": 11,
        "text": "(1) riportare la definizione di deadlock, includendo l'elenco e le definizioni delle condizioni necessarie al suo verificarsi, (2) descrivere e spiegare l'uso dei grafi di assegnazione delle risorse",
        "answer": "Risposta completa richiesta (max 5.00 punti)",
        "maxPoints": 5,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "domanda 11.png"
      },
      {
        "number": 12,
        "text": "(1) spiegare il dual mode e cosa si intende per system call, (2) dire cos'è e come viene usato il vettore delle interruzioni",
        "answer": "Risposta completa richiesta (max 5.00 punti)",
        "maxPoints": 5,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "domanda 12.png"
      }
    ]
  },
  {
    "id": "teoria-sample-001",
    "date": "2025.01.XX",
    "course": "A",
    "title": "Esame Teoria - Domande Multiple",
    "topics": [
      "generalita",
      "memoria-primaria",
      "file-system",
      "processi-scheduling",
      "sincronizzazione"
    ],
    "questions": [
      {
        "number": 1,
        "text": "Il sistema operativo gestisce la memoria virtuale utilizzando una tabella delle pagine che mappa gli indirizzi virtuali agli indirizzi fisici.",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero"
      },
      {
        "number": 2,
        "text": "La paginazione è una tecnica di gestione della memoria che divide la memoria fisica in blocchi di dimensione fisse chiamate pagine.",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero"
      },
      {
        "number": 3,
        "text": "La paginazione è una tecnica di gestione della memoria che divide la memoria fisica in blocchi di dimensioni variabili chiamati segmenti.",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso"
      },
      {
        "number": 4,
        "text": "Un file system è responsabile dell'organizzazione, archiviazione, recupero e gestione dei dati su dispositivi di memorizzazione, ma non gestisce la sicurezza dei dati.",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso"
      },
      {
        "number": 5,
        "text": "Un file system è responsabile dell'organizzazione, archiviazione, recupero e gestione dei dati su dispositivi di memorizzazione.",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero"
      },
      {
        "number": 6,
        "text": "Un thread è un'unità di esecuzione all'interno di un processo che condivide lo stesso spazio di indirizzamento e risorse del processo.",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero"
      },
      {
        "number": 7,
        "text": "Un thread è un'unità di esecuzione indipendente che non condivide lo stesso spazio di indirizzamento e risorse del processo.",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso"
      },
      {
        "number": 8,
        "text": "Un deadlock si verifica quando due o più processi si bloccano a vicenda, aspettando risorse che sono detenute dagli altri processi coinvolti.",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero"
      },
      {
        "number": 9,
        "text": "Un deadlock si verifica quando un processo acquisisce tutte le risorse necessarie senza mai rilasciarle.",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 1,
        "negativePoints": 0.5,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso"
      },
      {
        "number": 10,
        "text": "Quali delle seguenti condizioni non è necessaria affinché si verifichi un deadlock?",
        "answer": "Risposta corretta: Preemption",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "multianswer"
      },
      {
        "number": 11,
        "text": "Associa ciascun tipo di memoria virtuale alla sua tecnica di gestione",
        "answer": "APFS: macOS",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "matching",
        "pairs": [
          {
            "left": "APFS",
            "right": "macOS"
          }
        ]
      }
    ]
  },
  {
    "id": "so-appello-14-01-2025",
    "date": "2025.01.14",
    "course": "A",
    "title": "SO Appello 14/01/2025 - Teoria (33 punti)",
    "topics": [
      "generalita",
      "processi-scheduling",
      "sincronizzazione",
      "memoria-primaria",
      "memoria-massa",
      "file-system"
    ],
    "questions": [
      {
        "number": 1,
        "text": "Domanda 1 (vedi immagine 1.png)",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "1.png"
      },
      {
        "number": 2,
        "text": "Domanda 2 (vedi immagine 2.png)",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "2.png"
      },
      {
        "number": 3,
        "text": "Domanda 3 (vedi immagine 3.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "3.png"
      },
      {
        "number": 4,
        "text": "Domanda 4 (vedi immagine 4.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "4.png"
      },
      {
        "number": 5,
        "text": "Domanda 5 (vedi immagine 5.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "5.png"
      },
      {
        "number": 6,
        "text": "Domanda 6 (vedi immagine 6.png)",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "6.png"
      },
      {
        "number": 7,
        "text": "Domanda 7 (vedi immagine 7.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "7.png"
      },
      {
        "number": 8,
        "text": "Domanda 8 (vedi immagine 8.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "8.png"
      },
      {
        "number": 9,
        "text": "Domanda 9 (vedi immagine 9.png)",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "9.png"
      },
      {
        "number": 10,
        "text": "Domanda 10 (vedi immagine 10.png)",
        "answer": "La risposta corretta è: Vero",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": true
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": false
          }
        ],
        "correctAnswer": "vero",
        "imageRef": "10.png"
      },
      {
        "number": 11,
        "text": "Domanda 11 (vedi immagine 11.png)",
        "answer": "La risposta corretta è: Falso",
        "maxPoints": 2,
        "negativePoints": 1,
        "type": "true-false",
        "options": [
          {
            "id": "vero",
            "text": "Vero",
            "isCorrect": false
          },
          {
            "id": "falso",
            "text": "Falso",
            "isCorrect": true
          }
        ],
        "correctAnswer": "falso",
        "imageRef": "11.png"
      },
      {
        "number": 12,
        "text": "Domanda 12 (vedi immagine 12.png) - Seleziona le risposte corrette",
        "answer": "Risposte corrette: V-V-V-F-V",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "multianswer",
        "imageRef": "12.png",
        "correctAnswers": [
          "V",
          "V",
          "V",
          "F",
          "V"
        ]
      },
      {
        "number": 13,
        "text": "Domanda 13 (vedi immagine 13.png)",
        "answer": "Risposte corrette: evitare deadlock, ricerca pagina vittima, transazioni concorrenti asincrone, scheduling del disco",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "multianswer",
        "imageRef": "13.png"
      },
      {
        "number": 14,
        "text": "Domanda 14 (vedi immagine 14.png) - Seleziona le risposte corrette",
        "answer": "Risposte corrette: V-V-V-V-F",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "multianswer",
        "imageRef": "14.png",
        "correctAnswers": [
          "V",
          "V",
          "V",
          "V",
          "F"
        ]
      },
      {
        "number": 15,
        "text": "Domanda 15 (vedi immagine 15.png) - Seleziona le risposte corrette",
        "answer": "Risposte corrette: V-F-V-F-F",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "multianswer",
        "imageRef": "15.png",
        "correctAnswers": [
          "V",
          "F",
          "V",
          "F",
          "F"
        ]
      },
      {
        "number": 16,
        "text": "Domanda 16 (vedi immagine 16.png) - Seleziona le risposte corrette",
        "answer": "Risposte corrette: F-V-V-V-F",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "multianswer",
        "imageRef": "16.png",
        "correctAnswers": [
          "F",
          "V",
          "V",
          "V",
          "F"
        ]
      },
      {
        "number": 17,
        "text": "Domanda 17 (vedi immagine 17.png) - Seleziona le risposte corrette",
        "answer": "Risposte corrette: NO-NO-NO-SOLUZIONE-NO",
        "maxPoints": 3,
        "negativePoints": 1.5,
        "type": "multianswer",
        "imageRef": "17.png",
        "correctAnswers": [
          "NO",
          "NO",
          "NO",
          "SOLUZIONE",
          "NO"
        ]
      }
    ]
  },
  {
    "id": "2024-09-06",
    "date": "2024.09.06",
    "course": "A",
    "title": "2024.09.06 Prova di C, corso A",
    "questions": [
      {
        "number": 1,
        "text": "Si implementi la funzione con prototipo\nchar * get_sel(char * s, char sel);\ni cui parametri sono:\n- una stringa s (terminata dal carattere '\\0' come di consueto) e\n- un carattere sel diverso da '\\0'.\nLa funzione alloca e restituisce la sotto-stringa di **s** compresa fra la prima occorrenza (inclusa) di **sel** e la seconda (esclusa). Se è presente una sola occorrenza di **sel**, restituisce la sottostringa fino alla fine di **s**. Se **s** non contiene alcun carattere **sel**, restituisce **NULL**. Se, ad esempio, viene invocato get_sel(\"Italia Italia\",'i') viene ritornata la stringa \"a Ital\".",
        "answer": "char * get_sel(char * s, char sel)\n{\nchar * ret_str=NULL;\nint i;\n/* Scorri s fino a quando non termina oppure si trova sel */\nfor (; *s != 0 && *s != sel; s++);\nif (*s == sel) {\n/* Trovata un'occorrenza. Mi sposto al prossimo char */\ns++;\n/* Alloco spazio fino alla fne di s */\nret_str = malloc(strlen(s)+1);\n/* Cerco altra occorrenza (se c'e`) */\nfor (i=0; s[i] != 0 && s[i] != sel; i++) {\nret_str[i] = s[i];\n}\n/* Chiudo la stringa */\nret_str[i] = 0;\nret_str = realloc(ret_str, strlen(ret_str)+1); /* opzionale, per eventualmente ridurre la memoria occupata */\n}\nreturn ret_str;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "Sia data una lista i cui elementi sono definiti dalla seguente struct\nstruct node {\nint val;\nstruct node * next;\n};\nSi implementi la funzione dal seguente prototipostruct node * cut(struct node * head, int begin, int end);\ndove:\n- head è un puntatore alla testa di una lista;\n- begin e end rappresentano due posizioni all’interno della lista a partire da head, con begin<=end. Le posizioni sono numerare a partire da 0.\nLa funzione deve restituire, se possibile, la sotto-lista compresa tra le posizioni begin e end deallocando la rimanente parte. La funzione restituisce il puntatore alla testa della lista così calcolata o NULL se non è possibile. Ad esempio se la lista puntata da head e` la seguente\nhead->{4}->{7}->{3}->{8}->{2}->{1}\nallora cut(head,2,4) restituisce la lista\n{3}->{8}->{2}\ne dealloca gli altri nodi. Se end va oltre il termine della lista la funzione deve restituire la sottolista tra begin la fine della lista.",
        "answer": "/* Versione iterativa */\nstruct node * cut(struct node * head, int begin, int end)\n{\nstruct node * p, tmp=NULL;\nint i;\nif (head == NULL)\n/* Lista vuota */\nreturn NULL;\nfor (p=head, i=0; p != NULL && i <= end; i++) {\n/* tmp punta al nodo che precede p. */\n/* Se p punta alla testa, allora tmp e` NULL */\nif (i < begin) {\n/* Tagliare nodo in testa e avanzare head */\ntmp = head;\nhead = p = head->next;\nfree(tmp);\ntmp = NULL;\n} else {\ntmp = p;\np = p->next;\n}\n}\nif (tmp != NULL) {\n/* Chiudere ultimo elemento della lista */\ntmp->next = NULL;\n} else {\n/* Se tmp == NULL, non abbiamo salvato alcun nodo */\nhead = NULL;\n}\n/* Tagliare tutto da p in poi */\nwhile (p != NULL) {\ntmp = p->next;\nfree(p);\np = tmp;\n}\nreturn head;\n}\n/* Versione ricorsiva */\nstruct node * cut(struct node * head, int begin, int end)\n{\nstruct node * p;\nif (head == NULL)\n/* Lista vuota */\nreturn NULL;\nif (begin > end || end < 0) {\n/* Tagliare tutto da head in poi */\ndo {\np = head->next;\nfree(head);\nhead = p;\n} while (head != NULL);\nreturn NULL;\n}\n/* Adesso certamente: begin <= end && end >=0 */\nif (begin > 0) {\n/* Mi sposto in avanti e decremento sia begin che end */\np = cut(head->next, begin-1, end-1);\nfree(head); /* Testa da tagliare */\nreturn p;\n}\n/* Adesso certamente end >= begin >= 0 */\nhead->next = cut(head->next, begin, end-1);\nreturn head;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "memoria-primaria",
      "file-system"
    ]
  },
  {
    "id": "2024-09-06",
    "date": "2024.09.06",
    "course": "B",
    "title": "2024.09.06 Prova di C, corso B",
    "questions": [
      {
        "number": 1,
        "text": "Si implementi la funzione con prototipo\nchar * concatenate_strings(char ** v, unsigned int n);\nla quale legge in input l’array v di n puntatori a stringhe C, e ritorna il puntatore ad una stringa C ottenuta concatenando le stringhe puntate da v. Se per vari motivi questo non è possibile, viene ritornato NULL.\nNello svolgimento <b>non è possibile</b> usare le funzioni di libreria srtcat o strncat.",
        "answer": "Segue esempio di soluzione\n/* Omettere le include non e` penalizzante */\n#include <string.h>\n#include <stdlib.h>\nchar * concatenate_strings(char ** v, unsigned int n)\n{\nchar * ret_str = NULL;\nint i, j, cnt, len_i;\n/* cnt segue la posizione corrente dove inserire carattere */\nfor (i=0, cnt=0; i<n; i++) {\nlen_i = strlen(v[i]);\n/* realloc(NULL, X) equivale a malloc(X) */\nret_str = realloc(ret_str, cnt+len_i);\nfor (j=0; j<len_i; j++, cnt++) {\nret_str[cnt] = v[i][j];\n}\n}\n/* Aggiungi zero di chiusura */\nret_str = realloc(ret_str, cnt+1);\nret_str[cnt] = 0;\n/* Se n<=0 ritorna correttamente NULL */\nreturn ret_str;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "Sia data la seguente definizione di tipo utilizzata per rappresentare delle liste di valori interi:\ntypedef struct _node {\nint val;\nstruct _node * next;\n} node;Definire la funzione dal seguente prototipo:node * list_invert(node * head);\nla quale inverte l'ordine degli elementi memorizzati nella lista puntata da head passata come argomento. Se per esempio viene passata la seguente lista come argomento:\nhead → 1 → 2 → 3 → 4\nallora la chiamata list_invert(head) restituisce il puntatore alla lista così modificata:\n(valore di ritorno) → 4 → 3 → 2 → 1\n<b>ATTENZIONE</b>: La funzione non deve allocare una nuova lista nell'ottenere il risultato, ma soltanto scambiare opportunamente i nodi presenti.",
        "answer": "Soluzione iterativa\nnode * list_invert(node * head)\n{\nnode *item = head;  /* current node */\nnode *p = NULL;     /* predecessor of item, NULL if item is head */\nnode *t;            /* temporary pointer to save successor of item */\nwhile (item!=NULL){\nt = item->next;\nitem->next = p;\np = item;\nitem = t;\n}\nreturn p;\n}\nSoluzione ricorsiva\nnode * list_invert(node * head)\n{\nnode * inverted_next;\nif (head == NULL || head->next == NULL)\nreturn head;\ninverted_next = list_invert(head->next);\nhead->next->next = head;\nhead->next = NULL;\nreturn inverted_next;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "prova-febbraio-2024",
    "date": "2024.02.00",
    "course": "Teoria SO",
    "title": "Prova Febbraio 2024 - Sistemi Operativi",
    "duration": 120,
    "totalPoints": 30,
    "questions": [
      {
        "id": "prova-feb-2024-q1",
        "text": "Tutti i sistemi operativi moderni adottano una qualche forma di paginazione della memoria primaria, in quanto:\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "permette di eliminare la frammentazione esterna della RAM e di limitare moltissimo la frammentazione interna, permette di implementare una forma automatica di protezione dello spazio di indirizzamento dei processi, è la base a partire dalla quale si può implementare la memoria virtuale",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "permette di eliminare la frammentazione interna della RAM ma non quella esterna, permette di implementare una forma automatica di protezione dello spazio di indirizzamento dei processi, è la base a partire dalla quale si può implementare la memoria virtuale",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "permette di eliminare la frammentazione interna della RAM e di limitare moltissimo la frammentazione esterna, permette di implementare una forma automatica di protezione dello spazio di indirizzamento dei processi, è la base a partire dalla quale si può implementare la memoria virtuale",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "permette di eliminare la frammentazione esterna e la frammentazione interna della RAM, permette di usare codice dinamicamente rilocabile per i processi, è la base a partire dalla quale si può implementare la memoria virtuale",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-primaria"
        ]
      },
      {
        "id": "prova-feb-2024-q2",
        "text": "In hard disk grande 512 Gigabyte, per scrivere il numero di un blocco vengono usati 25 bit, arrotondati al minimo numero di byte necessario. L'hard disk adotta una allocazione indicizzata semplice, e di un file A si sa che nel suo blocco indice 12 byte vengono usati per tenere traccia dei blocchi di dati di A. Quanto può essere grande al massimo A?",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "24 Kilobyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "40 Kilobyte",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "48 Kilobyte",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "32 Kilobyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-massa",
          "file-system"
        ]
      },
      {
        "id": "prova-feb-2024-q3",
        "text": "In un sistema operativo che adotta uno scheduling senza diritto di prelazione, quattro processi arrivano al tempo indicato e consumano la quantità di CPU indicata nella tabella sottostante:\n\nProcesso | T. di arrivo | Burst\nPa       | 0            | 5\nPb       | 2            | 3\nPc       | 4            | 2\nPd       | 6            | 1\n\nSe si usa l'algoritmo di scheduling non preemptive che fornisce le migliori prestazioni possibili:\n- il waiting time medio è: [risposta]\n- il turnaround medio è: [risposta]\n- il diagramma di GANTT è: [selezione]\n- l'algoritmo usato può soffrire di starvation? [sì/no]",
        "type": "essay",
        "answer": "Waiting time medio = 2 (o 8/4), Turnaround medio = 19/4 (o 18/4), Diagramma GANTT: (0) ... Pa ... (5) ... Pc ... (7) ... Pd ... (8) ... Pb ... (11), Starvation: sì",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "processi-scheduling"
        ]
      },
      {
        "id": "prova-feb-2024-q4",
        "text": "Il concetto di 'diritto di prelazione' può essere applicato sia ad un algoritmo di scheduling che ad un kernel nel suo complesso. Qual è la differenza?\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "non c'è nessuna differenza: un algoritmo di scheduling preemptive implica che il sistema operativo su cui è implementato possieda un kernel con diritto di prelazione.",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "In un kernel con diritto di prelazione vengono disabilitati gli interrupt quando un processo è in kernel mode, in un algoritmo di scheduling con diritto di prelazione i processi utente possono essere interrotti da altri processi utente",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "negli algoritmi di scheduling preemptive un processo utente può essere obbligato dal SO ad abbandonare la CPU. Nei kernel preemptive un processo in kernel mode può essere obbligato ad abbandonare la CPU.",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "In un kernel con diritto di prelazione vengono disabilitati gli interrupt quando un processo è in kernel mode, in un algoritmo di scheduling con diritto di prelazione vengono abilitati gli interrupt per permettere il funzionamento del timer hardware",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "processi-scheduling"
        ]
      },
      {
        "id": "prova-feb-2024-q5",
        "text": "del codice statico e del codice staticamente rilocabile possiamo dire che:\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "nei sistemi operativi moderni non vengono usati perché non permetterebbero una implementazione efficiente della paginazione della memoria",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "nei sistemi operativi moderni non vengono usati perché producono codice molto meno efficiente di quello dinamicamente rilocabile",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "nei sistemi operativi moderni non vengono usati perché renderebbero impossibile l'implementazione della memoria virtuale",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "nei sistemi operativi moderni non vengono usati perché per girare in modo efficiente richiederebbero dell'hardware specifico che ne limiterebbe la portabilità",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-primaria"
        ]
      },
      {
        "id": "prova-feb-2024-q6",
        "text": "Dopo l'esecuzione dei seguenti comandi in un ambiente Unix (come visti a lezione):\n\n1: cd /tmp\n2: mkdir newfolder\n3: echo 'ciao' > pippo // crea un nuovo file di nome pippo contenente la stringa ciao\n4: cd newfolder\n5: ln ../pippo paperino\n6: ln -s /tmp/newfolder folder2\n7: cp paperino topolino\n8: echo 'salve' >> topolino // aggiunge 'salve' a fondo file\n9: rm pippo\n10: cat paperino // cat stampa il contenuto del file passato come argomento\n11: mkdir folder3\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di newfolder è: 2, 3. l'output del comando 10 è: 'ciao', 4. il link counter di tmp è: aumentato di 1",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "1. il link-counter dell'i-node di paperino è: 1, 2. il link counter di newfolder è: 3, 3. l'output del comando 10 è: 'ciao', 4. il link counter di tmp è: aumentato di 2",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di newfolder è: 3, 3. l'output del comando 10 è: 'ciao', 4. il link counter di tmp è: aumentato di 1",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "1. il link-counter dell'i-node di paperino è: 2, 2. il link counter di newfolder è: 3, 3. l'output del comando 10 è: no such file or directory, 4. il link counter di tmp è: aumentato di 1",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "file-system"
        ]
      },
      {
        "id": "prova-feb-2024-q7",
        "text": "Cosa succede quando si esegue la close su un file, in un generico sistema operativo?\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "si comunica al sistema operativo che non si vuole più usare quel file. Tutte le informazioni del file che erano state copiate in memoria primaria possono quindi venire rimosse, ma non prima di essere state salvate in memoria secondaria se è necessario",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "si comunica al sistema operativo che non si vuole più usare quel file. Tutte le informazioni del file che erano state copiate in memoria primaria possono quindi venire rimosse, ma non prima di essere state salvate in memoria secondaria se è necessario",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "si comunica al sistema operativo che non si vuole più usare quel file. Tutte le informazioni del file che erano state copiate in memoria primaria possono quindi venire rimosse, e analogamente i file viene rimosso dalla memoria secondaria",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "si comunica al sistema operativo che non si vuole più usare quel file. Tutte le informazioni del file che erano state copiate in memoria primaria possono quindi venire rimosse, ma non prima di essere state spostate nell'area swap, dove sarà più facile recuperarle se il file viene riaperto a breve",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "file-system"
        ]
      },
      {
        "id": "prova-feb-2024-q8",
        "text": "Si consideri questa variante del problema dei produttori e consumatori:\n\nSemaphore mutex = 1; full =0; empty =N;\n\ncodice consumatore:\nrepeat\n  wait(empty);\n  wait(mutex);\n  <preleva dato dal buffer>\n  signal(mutex)\n  signal(full);\n  <consuma dato>\nforever\n\ncodice produttore:\nrepeat\n  <produci dato>\n  wait(full)\n  <inserisci dato nel buffer>\n  signal(empty)\nforever\n\nQuesta soluzione funziona? Se sì, a quali condizioni? Se no, perché?\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "La soluzione proposta funziona, e corrisponde al caso in cui è presente un solo produttore, visto che l'operazione di inserimento non è protetta dal semaforo di mutua esclusione",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "La soluzione proposta non funziona in nessun caso, perché i semafori coinvolti nelle operazioni di sincronizzazione non sono usati in modo corretto",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "La soluzione proposta funziona a condizione che i produttori accedano al buffer condiviso i momenti diversi, visto che l'operazione di inserimento non è protetta dal semaforo di mutua esclusione",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "La soluzione proposta non funziona, visto che l'inserimento di un dato non è protetto dal semaforo di mutua esclusione e quindi due produttori potrebbero accedere al buffer contemporaneamente",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "sincronizzazione"
        ]
      },
      {
        "id": "prova-feb-2024-q9",
        "text": "Di un sistema è noto che la tabella delle pagine più grande del sistema occupa esattamente 2 frame, il numero di un frame è scritto su 4 byte usando però solo i primi 22 bit, e nel sistema sono presenti in media 4 processi che insieme producono una frammentazione interna complessiva media di 64 Kilobyte.\n\nQuanto sono grandi lo spazio di indirizzamento logico e fisico del sistema?",
        "type": "essay",
        "answer": "Lo spazio logico del sistema è grande: 512 Megabyte. Lo spazio fisico del sistema è grande: 128 Gigabyte",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-primaria"
        ]
      },
      {
        "id": "prova-feb-2024-q10",
        "text": "In quale/i caso/i un processo in coda di ready viene fatto passare allo stato running?\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "quando il processo è entrato in RQ arrivando da una coda di waiting, perché significa che è disponibile l'informazione che il processo stava attendendo, e la sua computazione può ripartire",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "solo quando è l'unico processo nella coda, altrimenti dovrà aspettare che siano stati mandati in esecuzione i processi che nella coda vengono prima di lui.",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "quando il sistema operativo ha terminato le operazioni necessarie ad amministrare la vita del processo, ad esempio ha allocato il processo in RAM e inizializzato il suo PCB",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "quando lo scheduler della CPU lo seleziona per entrare in esecuzione. Ad esempio, nel caso di FCFS, quando il processo si trova in cima alla coda di ready",
            "isCorrect": true
          }
        ],
        "correctAnswer": "d",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "processi-scheduling"
        ]
      },
      {
        "id": "prova-feb-2024-q11",
        "text": "Riguardo ai link fisici nell'ambiente Unix, secondo quanto visto a lezione possiamo dire che:\n\nScegli un'alternativa:",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "permettono un accesso più lento ai file e occupano più spazio dei link simbolici, e sono ammessi sia tra file regolari che tra cartelle, anche se con alcune restrizioni",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "permettono un accesso più lento ai file e occupano più spazio dei link simbolici, e sono ammessi solo tra file regolari perché tra cartelle sono ammessi solo i link simbolici",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "permettono un accesso più veloce ai file e occupano meno spazio dei link simbolici, e sono ammessi solo tra file regolari perché tra cartelle sono ammessi solo i link simbolici",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "permettono un accesso più veloce ai file e occupano meno spazio dei link simbolici, e sono ammessi sia tra file regolari che tra cartelle, anche se con alcune restrizioni",
            "isCorrect": true
          }
        ],
        "correctAnswer": "d",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "file-system"
        ]
      },
      {
        "id": "prova-feb-2024-q12",
        "text": "Su un hard disk che adotta una allocazione concatenata (senza FAT) è memorizzato un file A della dimensione di 0x4000 byte, e si sa che nell'ultimo blocco di A sono presenti 8 byte del file. Si sa inoltre che per scrivere il numero di un blocco vengono usati 29 bit, arrotondati al minimo numero di byte necessario. Quanto è grosso l'hard disk?",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "2 Terabyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "4 Terabyte",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "512 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "1 Terabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-massa",
          "file-system"
        ]
      },
      {
        "id": "prova-feb-2024-q13",
        "text": "si consideri l'esecuzione della seguente porzione di codice che utilizza la system call fork:\n\nint a, b, c, d, n, pid1, pid2, pid3;\na = 30, b = 40, c = 50, d = 60;\nn = fork();\nif ( n == 0)\n  {a = 35; b = 45;\n  pid1 = getpid();\n  printf('%d', pid1);\n  exit(0);}\nelse\n  {c = 55; d = 65;\n  pid2 = getpid();\n  printf('%d',pid2);\n  pid3 = wait(NULL);\n  exit(0);}\n\nDeterminare:\n- il valore della variabile a vista dal processo figlio subito prima della sua exit è: [risposta]\n- il valore della variabile c vista dal processo figlio subito prima della sua exit è: [risposta]\n- il valore della variabile b vista dal processo padre subito prima della sua exit è: [risposta]\n- il valore della variabile d vista dal processo padre subito prima della sua exit è: [risposta]\n- all'esecuzione delle due printf vale la seguente relazione: [selezione tra pid1 = pid2, pid1 < pid2, ecc.]\n- del risultato della wait possiamo dire che: [selezione tra pid1 < pid3, pid1 = pid3, ecc.]",
        "type": "essay",
        "answer": "a (figlio) = 35, c (figlio) = 50, b (padre) = 40, d (padre) = 65, relazione printf: pid1 = pid2 (falso, dovrebbe essere pid1 ≠ pid2), wait: pid1 < pid3 (o pid1 = pid3)",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "processi-scheduling"
        ]
      },
      {
        "id": "prova-feb-2024-q14",
        "text": "Un sistema ha un tempo di accesso in RAM di 110 ns, adotta un TLB con un tempo di accesso di 10 ns e un hit rate del 90%, e usa un algoritmo di rimpiazzamento delle pagine. Quando si verifica un hit la pagina indirizzata è sicuramente in RAM. Quando si verifica un miss, nel 20% dei casi la pagina indirizzata non è in RAM e il page fault ha un costo totale di gestione di 1 microsecondo, indipendentemente dal valore del dirty bit. Qual è l'effective access time (eat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB, e in caso di page fault si consideri solo il tempo di gestione del page fault)",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "mat = 145,6 ns",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "mat = 156,6 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "mat = 124,6 ns",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "mat = 134,6 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-primaria"
        ]
      },
      {
        "id": "prova-feb-2024-q15",
        "text": "In un sistema operativo un indirizzo fisico è scritto su 28 bit, l'offset più grande in una pagina è 3FFF, e lo spazio logico è il doppio di quello fisico.\n\nSe il sistema adottasse una Inverted Page Table della dimensione di 64 Kilobyte, quanti potrebbero essere al massimo i processi presenti contemporaneamente nel sistema?",
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "2^10 processi",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "2^17 processi",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "2^20 processi",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "2^14 processi",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "maxPoints": 2,
        "negativePoints": 0,
        "topics": [
          "memoria-primaria"
        ]
      }
    ]
  },
  {
    "id": "2024-01-19",
    "date": "2024.01.19",
    "course": "A",
    "title": "2024.01.19 Prova di C, corso A",
    "questions": [
      {
        "number": 1,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">**[English version below]**\n<p dir=\"ltr\" style=\"text-align: left;\">Si definisca la seguente funzione C\nchar *substr(char *s, char first, char last)\n<p dir=\"ltr\" style=\"text-align: left;\">la quale restituisce **una copia** la sotto-stringa della stringa **s** che inizia dalla prima occorrenza del carattere **first** alla prima occorrenza del carattere **last** che segue first, estremi inclusi. Casi particolari:\n<ul dir=\"ltr\">\n<li style=\"text-align: left;\">se first non e` presente in s, viene restituito NULL\n<li style=\"text-align: left;\">se first non e` seguito da alcun carattere last, viene restituita la stringa dal carattere first, fino alla fine di s\n<p dir=\"ltr\" style=\"text-align: left;\">Ad esempio:\nsubstr(\"Per me si va ne la città dolente, per me si va ne l'etterno dolore\",&nbsp;'v', 'r')\n<p dir=\"ltr\" style=\"text-align: left;\">restituisce per copia la stringa:\n\"va ne la città dolente, per\"\n**[English version]**\n****\n<p dir=\"ltr\"><span>Define the following C function\n</span>\n<span>\nchar *substr(char *s, char first, char last)\n<p dir=\"ltr\">which returns **a copy** of the sub-string **s**<span>, starting from the first occurrence of **first** and ends at the first occurrence of **last** after first, extremes included</span>. Special cases:\n<ul dir=\"ltr\">\n- if first is not in s, the NULL is returned\n- if no **last **character follows any **first**, it is returned the string until the end of s\n<p dir=\"ltr\">For example:\nsubstr(\"Per me si va ne la città dolente, per me si va ne l'etterno dolore\",&nbsp;'v', 'r')\n<p dir=\"ltr\">returns a copy of the following string\n\"va ne la città dolente, per\"\n</span>****",
        "answer": "<p dir=\"ltr\" style=\"text-align: left;\">#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar *substr(char *s, char first, char last){\n&nbsp;&nbsp; &nbsp;char *c=s;\n&nbsp;&nbsp; &nbsp;char *ss=NULL;\n&nbsp;&nbsp; &nbsp;char a;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp;&nbsp; while ( (a=*c)!='\\0' && a!=first)&nbsp;&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c++;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;if (a!='\\0'){ // a==first&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *start=c; // memorizzo in start l'indirizzo del primo first di s\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; do{\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; c++;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }while ((a=*c)!='\\0' && a!=last); // cerco last in s\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (a!='\\0') // se trovo last sposto il punatatore c una posizione oltre\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c++;\n&nbsp;&nbsp; &nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ss=malloc(sizeof(char)* (c-start+1));\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *t=ss;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (start!=c)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *t++=*start++;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *t='\\0';\n&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;return ss;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "**[English version at the bottom]**\n<p dir=\"ltr\" style=\"text-align: left;\">Data la seguente definizione di nodo per rappresentare delle liste di valori interi:\n/* Nodo della lista */\ntypedef struct _node {\n&nbsp;&nbsp;&nbsp; int val;\n&nbsp;&nbsp;&nbsp; struct _node *next;\n} node;\nSi definisca la seguente funzione su liste:\nnode * list_cut_minmax(node * ls);\n<span>la quale elimini dalla lista i nodi con valore massimo e minimo. Casi particolari:</span>\n- se\nsono presenti piu` nodi con lo stesso valore massimo (o minimo) se ne\nelimini soltanto uno fra quelli con lo stesso valore, a scelta\n- se massimo e minimo coincidono (quindi tutti i valori sono uguali) si puo` segliere se eliminare uno o due nodi.\n<p dir=\"ltr\">Ad esempio se ls punta alla testa della seguente lista\nls -> 3 -> 8 -> 4 -> 2\nallora l'invocazione list_cut_minmax(ls) restituisce la lista così modificata:\n[valore restituito da list_shift] -> 3 -> 4\n<p dir=\"ltr\">dalla quale sono stati eliminati i nodi 8 e 2 con valori massimo e minimo.\n<p dir=\"ltr\">Soluzioni inefficienti, ovvero che scorrono la lista piu` di una volta, sono leggermente penalizzate (-1 punto).\n<p dir=\"ltr\">****\n**[English version]**\n<p dir=\"ltr\">Given the following definition of node to represent lists of integers:\n/* Nodo della lista */\ntypedef struct _node {\n&nbsp;&nbsp;&nbsp; int val;\n&nbsp;&nbsp;&nbsp; struct _node *next;\n} node;\nDefine the following C function over lists:\nnode * list_cut_minmax(node * ls);\nwhich erases from the list the nodes with minimum and maximum values. Special cases:\n- if more than one node have the same maximum (or minimum) value, just erase one of them of your choice\n- if maximum and minimum coincide (meaning that all values are the same), feel free to choose if erasing one or two nodes.\n<p dir=\"ltr\">For example, if ls points to the head of the list\nls -> 3 -> 8 -> 4 -> 2\nthen, the invocation of list_cut_minmax(ls) returns the following modified list:\n[returned pointer] -> 3 -> 4\n<p dir=\"ltr\">from which the nodes with values 8 and 2 are erased.\n<p dir=\"ltr\">Inefficient solutions which browse the list more than once, are slightly penalized (-1 point).\n<p dir=\"ltr\">",
        "answer": "node * list_cut_minmax(node * ls) {\n/* We also need pointer to previous nodes to keep the list linked */\nnode *curr_max, *prev_max;\nnode *prev_min, *curr_min;\nnode *curr, *prev;\t\t/* to browse the list */\nif (ls == NULL)\t\t\t/* empty list: nothing to do */\nreturn NULL;\n/* Initialization */\ncurr_max = curr_min = ls;\nprev_max = prev_min = NULL;\n/* Browse from ls->next as the head element is checked already */\nfor (prev=ls, curr=ls->next; curr!=NULL; prev=curr, curr=curr->next) {\nif(curr->value > curr_max->value) {\ncurr_max = curr;\nprev_max = prev;\n}\nif(curr->value < curr_min->value) {\ncurr_min = curr;\nprev_min = prev;\n}\n}\n/* If min==max, all nodes are the same, we just erase the head */\nif (curr_min == curr_max) {\nls = curr_min->next;\nfree(curr_min);\nreturn ls;\n}\n/* Erasing min node first (this is an arbitrary choice) */\nif (prev_max == curr_min)\t/* if min->max, we need to update prev_max */\nprev_max = prev_min;\nif (prev_min == NULL)\t\t/* Erasing the head */\nls = curr_min->next;\nelse\t\t\t\t/* Erasing non-head nodes */\nprev_min->next = curr_min->next;\nfree(curr_min);\n/* Now erasing max node */\nif (prev_max == NULL)\nls = curr_max->next;\nelse\nprev_max->next = curr_max->next;\nfree(curr_max);\nreturn ls;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "2024-01-19",
    "date": "2024.01.19",
    "course": "B",
    "title": "2024.01.19 Prova di C, corso B",
    "questions": [
      {
        "number": 1,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">**[English version below]**\n<p dir=\"ltr\" style=\"text-align: left;\">Si definisca la seguente funzione C:\nchar *strtrim(char *s, unsigned int start, unsigned int end)\n<p dir=\"ltr\" style=\"text-align: left;\">dove **s** è un puntatore ad una stringa C allocata dinamicamente prima dell'invocazione della funzione.\nLa funzione modifica e restituisce la stringa **s** dalla quale sono stati eliminati i caratteri che vanno dalla posizione **start** alla posizione **end**, estremi inclusi. Nel compiere l'eliminazione, la funzione deve ridurre  tramite re-allocazione (realloc) la memoria assegnata ad **s** al minimo necessario. Le posizioni in s, sono contate a partire da zero.\nLa funzione deve essere robusta e verificare che **a** e **b** abbiano valori consistenti.\nAd esempio se:\ns -> \"Per me si va HELLO ne la città dolente\"\n<p dir=\"ltr\" style=\"text-align: left;\">allora dopo la chiamata **strtrim(s, 13, 17)** la memoria puntata da **s** ha il seguente contenuto:\ns -> \"Per me si va  ne la città dolente\"\n<p dir=\"ltr\">**[English version]**\n<p dir=\"ltr\">Define the following C function\nchar *strtrim(char *s, unsigned int start, unsigned int end)\n<p dir=\"ltr\">with **s** being the pointer to a C string dynamically allocated before the function invocation.\nThe function modifies and returns the string  **s** with all characters from position **start** to position **end**, extremes included, erased from s. When erasing the characters, the function reallocates (with realloc) the memory assigned to **s** to the minimum necessary. The character positions over **s** are counted from zero.\nThe function must check the consistency of the input parameters start and end.\nFor example, if:\ns -> \"Per me si va HELLO ne la città dolente\"\n<p dir=\"ltr\">then after invoking **strtrim(s, 13, 17)**, the memory pointed by s contains\ns -> \"Per me si va  ne la città dolente\"",
        "answer": "<p dir=\"ltr\" style=\"text-align: left;\">#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nchar *strtrim(char *s, unsigned int a, unsigned int b){\n&nbsp; &nbsp;\n&nbsp;&nbsp; int l = strlen(s); // numero caratteri stringa escluso '\\0'\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; // utile per verifica parametri\n&nbsp;&nbsp; if (b<l && a<=b){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *dst = s+a;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp; char *src = s+b+1;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp; int i=0;\n&nbsp;&nbsp; &nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (*src!='\\0')&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *dst++ = *src++;\n&nbsp;&nbsp; &nbsp;&nbsp; *dst = '\\0';\n&nbsp;&nbsp; &nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp; s = realloc(s, l-(b-a)); // per esteso sarebbe: l+1-(b-a+1)\n&nbsp;&nbsp; }\n&nbsp;&nbsp; return s;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">**[English version at the bottom]**\n<p dir=\"ltr\" style=\"text-align: left;\">Data la seguente definizione di nodo per rappresentare delle liste di valori interi:\n/* Nodo della lista */\ntypedef struct _node {\n&nbsp;&nbsp;&nbsp; int val;\n&nbsp;&nbsp;&nbsp; struct _node *next;\n} node;\nSi definisca la seguente funzione su liste:\nnode * list_shift(node * ls, unsigned int n);\nla quale operi uno **shift circolare a destra** della lista ls di n posizioni: si spostano gli elementi a destra (verso la coda) di n posizioni, riportando in testa gli elementi spostati oltre la coda.\n<p dir=\"ltr\" style=\"text-align: left;\">Ad esempio se ls punta alla testa della seguente lista\nls -> 3 -> 8 -> 4 -> 2 -> 1 -> 11 -> 111\nallora l'invocazione list_shift(ls, 3) restituisce la lista così modificata:\n[valore restituito da list_shift] -> 1 -> 11 -> 111 -> 3 -> 8 -> 4 -> 2\n<p dir=\"ltr\" style=\"text-align: left;\">La funzione deve operare sui puntatori ai nodi **senza** creare, copiare o eliminare i nodi stessi.\n<p dir=\"ltr\" style=\"text-align: left;\">\n<p dir=\"ltr\">****\n<p dir=\"ltr\">**[English version]**\n<p dir=\"ltr\">Given the following definition of node to represent lists of integers:\n/* Nodo della lista */\ntypedef struct _node {\n&nbsp;&nbsp;&nbsp; int val;\n&nbsp;&nbsp;&nbsp; struct _node *next;\n} node;\nDefine the following C function over lists:\nnode * list_shift(node * ls, unsigned int n);\nwhich performs a **circular shift to the right** by n positions:\n- nodes of the list are shifted to the right by n positions.\n- the nodes moved beyond the tail node are then moved back to the head.\n<p dir=\"ltr\">For example, if  ls points to the head of the following list\nls -> 3 -> 8 -> 4 -> 2 -> 1 -> 11 -> 111\nthen the invocation of list_shift(ls, 3) returns the following list:\n[valore restituito da list_shift] -> 1 -> 11 -> 111 -> 3 -> 8 -> 4 -> 2\n<p dir=\"ltr\">The function must operate over the **pointers to the nodes**, without creating, copying, or erasing nodes of the list.",
        "answer": "node * list_shift(node * ls, unsigned int n)\n{\nnode * cur;\nunsigned int len;\n/* Easy exit conditions */\nif (n == 0)\nreturn ls;\nif (ls == NULL || ls->next == NULL)\nreturn ls;\n/* Count the nodes in the list */\nfor (cur = ls, len = 1; cur->next != NULL; cur = cur->next, len++);\n/* We can use the remainder of n modulo len */\nn = n % len;\nif (n == 0)\nreturn ls;\n/* Make the list circular */\ncur->next = ls;\n/* n becomes the number of iterations to find the new head from ls */\nn = len-n-1;\nfor (cur = ls; n>0; cur = cur->next, n--);\n/* Now cur points to the node preceding the new head: we need it to close the list */\nls = cur->next;\t\t/* new head */\ncur->next = NULL;\t/* close the list */\nreturn ls;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "memoria-primaria",
      "file-system"
    ]
  },
  {
    "id": "domande-aperte-corso-b",
    "date": "2024.00.00",
    "course": "B",
    "title": "Domande Aperte Corso B - Teoria SO (13 Domande Essay)",
    "topics": [
      "generalita",
      "processi-scheduling",
      "sincronizzazione",
      "memoria-primaria",
      "file-system"
    ],
    "questions": [
      {
        "number": 1,
        "text": "I \"grafi di allocazione delle risorse\" sono strumenti di rilevazione o di prevenzione del deadlock? In quale modo possono essere usati a questo scopo? Vi sono eventuali vincoli?",
        "answer": "I grafi di allocazione delle risorse sono strumenti di rilevazione del deadlock.\n\nI grafi permettono di rappresentare graficamente le assegnazioni delle risorse ai processi. Se il grafo non contiene cicli, non c'è deadlock. Se il grafo contiene un ciclo con risorse aventi tutte una sola istanza, c'è deadlock. Se il ciclo comprende risorse con più istanze, il ciclo è condizione necessaria ma non sufficiente.\n\nL'uso dei grafi come strumento di rilevazione non prevede vincoli particolari.",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "sincronizzazione",
          "deadlock"
        ]
      },
      {
        "number": 2,
        "text": "(1) Si spieghi per quale motivo i metodi di allocazione della RAM per i processi kernel devono essere diversi da quelli per i processi utente e (2) si illustri il metodo di allocazione noto come sistema buddy.",
        "answer": "(1) I metodi di allocazione RAM per i processi kernel devono essere diversi per due motivi principali:\n- Strutture dati variabili: I processi kernel gestiscono strutture dati che cambiano dimensione (liste, code)\n- Memoria contigua: Alcuni processi kernel, specialmente quelli che lavorano con l'hardware, necessitano di memoria contigua per operazioni I/O\n\n(2) Il sistema buddy:\n- Suddivide la memoria in blocchi di dimensione pari a potenze di 2\n- Cerca il blocco più piccolo sufficiente per la richiesta\n- Se il blocco è troppo grande, lo divide in due blocchi \"buddy\" di dimensione pari alla metà\n- Quando un blocco viene liberato, verifica se il suo \"buddy\" è libero e li fonde insieme\n- Vantaggi: semplice da implementare, riduce frammentazione esterna\n- Svantaggi: può causare frammentazione interna significativa",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "memoria-primaria",
          "kernel"
        ]
      },
      {
        "number": 3,
        "text": "(1) Spiegare il dual mode e cosa si intende per system call, (2) dire cos'è e come viene usato il vettore delle interruzioni.",
        "answer": "(1) Dual mode e system call:\nIl dual mode prevede la divisione dell'instruction set in:\n- Istruzioni privilegiate (eseguibili solo dal SO in modalità kernel)\n- Istruzioni non privilegiate (eseguibili in modalità utente)\nSi basa su un bit di modalità (0=kernel, 1=utente).\n\nLe system call sono meccanismi che permettono ai processi utente di richiedere al SO di eseguire operazioni privilegiate. Durante una system call: il processo invia una trap, il SO passa in modalità kernel, esegue l'operazione, ritorna in modalità utente.\n\n(2) Vettore delle interruzioni:\nÈ una tabella contenente gli indirizzi degli handler degli interrupt. Quando si verifica un'interruzione:\n- L'hardware genera un segnale con l'ID dell'interruzione\n- La CPU usa l'ID come indice nel vettore per ottenere l'indirizzo dell'handler\n- Salva lo stato corrente ed esegue l'handler",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "generalita",
          "system-call",
          "interruzioni"
        ]
      },
      {
        "number": 4,
        "text": "(1) Spiegare cosa si intende per parallelismo virtuale, compresi quali fondamenti rendano possibile tale meccanismo. (2) Cos'è e come viene gestito dal SO un context switch.",
        "answer": "(1) Parallelismo virtuale:\nÈ un meccanismo che consente di eseguire più processi \"contemporaneamente\" su un singolo processore, dando l'illusione di esecuzione parallela. Il processore esegue solo un processo alla volta, ma la commutazione è così rapida da creare l'impressione di simultaneità.\n\nFondamenti che lo rendono possibile:\n- Multiprogrammazione: gestione di più processi contemporaneamente\n- Scheduling della CPU: algoritmo per decidere quale processo eseguire\n- Interruzioni: segnali per interrompere l'esecuzione e passare ad altro processo\n- Context Switch: meccanismo per salvare/caricare stato processi\n\n(2) Context switch:\nÈ il processo di salvataggio dello stato di un processo in esecuzione e caricamento dello stato di un altro processo. È gestito dal SO ed è un'operazione costosa. Si verifica durante interruzioni hardware o system call.",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "processi-scheduling",
          "context-switch"
        ]
      },
      {
        "number": 5,
        "text": "(1) Si spieghi che cos'è e a che cosa serve una tabella delle pagine. (2) Si spieghi perché il suo mantenimento in RAM rallenta l'esecuzione.",
        "answer": "(1) Tabella delle pagine:\nÈ una struttura dati per gestire la memoria virtuale, che funge da mappa per tradurre indirizzi logici in indirizzi fisici. Ogni processo ha la propria tabella memorizzata in RAM, contenente una entry per ogni pagina. Ogni entry contiene:\n- Numero di frame corrispondente\n- Bit di validità\n- Dirty bit\n- Bit di protezione\n\nConsente di: mappare indirizzi logici su fisici, implementare demand paging, proteggere la memoria, condividere pagine tra processi.\n\n(2) Rallentamento esecuzione:\nMantenere la tabella in RAM rallenta perché per ogni accesso alla memoria servono DUE accessi alla RAM:\n1. Accesso alla tabella delle pagine per trovare l'entry\n2. Accesso all'indirizzo fisico ottenuto\n\nPer mitigare il problema si usa il TLB (Translation Look-aside Buffer), una cache che memorizza le traduzioni più recenti.",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "memoria-primaria",
          "paginazione",
          "TLB"
        ]
      },
      {
        "number": 6,
        "text": "(1) Si spieghi cos'è test-and-set e (2) si spieghi come controllare una sezione critica tramite test-and-set.",
        "answer": "(1) Test-and-set:\nÈ un'istruzione atomica fornita dall'hardware per la sincronizzazione dei processi. Prende come parametro un puntatore ad una variabile booleana e svolge atomicamente:\n1. Salva il valore originale della variabile\n2. Imposta la variabile a true\n3. Restituisce il valore originale\n\n(2) Controllo sezione critica:\nSi usa una variabile booleana globale \"lock\" inizializzata a false.\n\nCodice:\nwhile (TestAndSet(&lock)); // Sezione di ingresso\n<sezione critica>\nlock = false;             // Sezione di uscita\n\nSe lock è true, un altro processo è nella sezione critica, quindi si aspetta nel while. Quando lock diventa false, il processo entra e imposta lock a true. L'atomicità garantisce che solo un processo alla volta ottenga il lock.",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "sincronizzazione",
          "sezione-critica",
          "test-and-set"
        ]
      },
      {
        "number": 7,
        "text": "(1) Si spieghi che cos'è una system call (2) si spieghi cosa permettono di fare e si faccia un esempio di system call",
        "answer": "(1) System call:\nÈ un meccanismo che consente ai processi in modalità utente di richiedere servizi al sistema operativo che opera in modalità kernel. È un'interfaccia tra programmi utente e SO per eseguire operazioni che richiedono privilegi speciali.\n\n(2) Cosa permettono di fare:\n- Controllo dei Processi: creare, terminare, sospendere processi\n- Gestione dei File: creare, aprire, leggere, scrivere, cancellare file\n- Gestione dei Dispositivi: richiedere/rilasciare dispositivi, leggere/scrivere\n- Gestione delle Informazioni: ottenere info sul sistema\n- Comunicazione: inviare/ricevere messaggi tra processi\n\nEsempio: open() in Unix apre un file e restituisce un file descriptor che può essere usato da altre system call come read() e write().",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "generalita",
          "system-call"
        ]
      },
      {
        "number": 8,
        "text": "1) Spiegare in cosa consiste il problema della sezione critica. 2) Elencare e definire le tre proprietà di una buona soluzione al problema della sezione critica",
        "answer": "1) Problema della sezione critica:\nRiguarda la gestione di dati condivisi in un sistema concorrente. Una sezione critica è una porzione di codice in cui un processo modifica variabili condivise. Solo un processo alla volta può essere nella sua sezione critica (mutua esclusione), altrimenti si verificano inconsistenze.\n\n2) Tre proprietà di una buona soluzione:\n- Mutua esclusione: Solo un processo alla volta può eseguire la propria sezione critica\n- Progresso: Nessun processo che non sia interessato alla sezione critica può bloccare altri processi dall'accedervi. Solo i processi interessati concorrono a determinare chi entrerà\n- Attesa limitata: Esiste un limite superiore al tempo di attesa per un processo che desidera entrare in sezione critica",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "sincronizzazione",
          "sezione-critica"
        ]
      },
      {
        "number": 9,
        "text": "(1) Spiegare cos'è il vettore delle interruzione e come viene usato per gestire gli eventi. (2) Spiegare in quali circostanze occorre un page fault",
        "answer": "(1) Vettore delle interruzioni:\nÈ un array di puntatori a funzioni di gestione eventi. Ogni evento ha un ID univoco corrispondente all'indice del vettore. Funzionamento:\n- Dispositivo/programma genera interruzione\n- CPU salva stato e identifica ID interruzione\n- ID usato come indice nel vettore per trovare routine di gestione\n- CPU esegue routine di gestione\n- Ripristina stato e riprende esecuzione\n\n(2) Page fault:\nSi verifica quando un processo cerca di accedere ad una pagina di memoria virtuale non presente in RAM. Circostanze:\n- Pagina non caricata: mai stata caricata in RAM\n- Pagina in memoria secondaria: caricata in precedenza ma sostituita\n- Accesso non valido: accesso a pagina non assegnata o senza permessi\n\nIl SO interrompe il processo e gestisce il page fault caricando la pagina richiesta. Se non c'è spazio, trova una pagina vittima da spostare in memoria secondaria (algoritmi: Second Chance, LRU).",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "generalita",
          "interruzioni",
          "memoria-primaria",
          "page-fault"
        ]
      },
      {
        "number": 10,
        "text": "(1) Spiegare cosa sono e dove sono memorizzati gli INODE e (2) spiegare l'allocazione concatenata dei blocchi ai file.",
        "answer": "(1) INODE (Index Node o FCB):\nSono strutture dati fondamentali nei file system che memorizzano i metadati di un file (eccetto nome e dati). Contenuto tipico:\n- User ID proprietario\n- Tipo file (regolare, directory, link, device)\n- Diritti di accesso\n- Tempi di accesso/modifica\n- Numero di link\n- Dimensione file\n- Puntatori ai blocchi dati\n\nQuando un file è aperto, il suo FCB viene aggiunto alla lista dei file aperti. Se in uso da un processo, l'INODE viene caricato in RAM come \"in-core inode\". Si usa l'algoritmo namei per risalire all'INODE tramite path.\n\n(2) Allocazione concatenata:\nI file sono allocati in blocchi collegati come catena. Ogni blocco contiene dati e puntatore al blocco successivo. L'INODE contiene puntatore al primo blocco.\n\nVantaggi: blocchi non contigui, aggiunta blocchi rapida, niente frammentazione esterna\nSvantaggi: lettura lenta (scorrere tutta catena), puntatore danneggiato rende file illeggibile",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "file-system",
          "INODE",
          "allocazione-file"
        ]
      },
      {
        "number": 11,
        "text": "(1) Elencare e definire le tre proprietà di una buona soluzione al problema della sezione critica; (2) Con riferimento al seguente codice (dove S è un semaforo inizializzato a 2) dire e spiegare se soddisfa tali proprietà: P(S) ... Sezione Critica ... V(S)",
        "answer": "(1) Tre proprietà:\n- Mutua Esclusione: Solo un processo alla volta può accedere alla sezione critica\n- Progresso: Se nessun processo è nella sezione critica, un processo che desidera entrarvi deve poterlo fare senza blocco indefinito\n- Attesa Limitata: Esiste un limite massimo al tempo di attesa prima di accedere alla sezione critica\n\n(2) Analisi codice con S=2:\nAssunzioni: P(S) e V(S) sono atomiche e implementate correttamente.\n\nSoddisfazione proprietà:\n- Mutua Esclusione: NON soddisfatta. S=2 significa che DUE processi possono entrare contemporaneamente nella sezione critica. Per mutua esclusione serve S=1.\n- Progresso: Soddisfatta. Se nessun processo è nella sezione critica (S=2), un processo che esegue P(S) può accedere.\n- Attesa Limitata: Soddisfatta. L'attesa è limitata dal numero di processi che possono accedere (2 in questo caso).",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "sincronizzazione",
          "sezione-critica",
          "semafori"
        ]
      },
      {
        "number": 12,
        "text": "(1) Spiegare cosa si intende per \"interleaving delle istruzioni\". (2) Spiegare come tale meccanismo supporta la realizzazione del multi-tasking",
        "answer": "(1) Interleaving delle istruzioni:\nÈ l'interfogliamento delle istruzioni, ovvero la capacità del SO di eseguire in modo interleaved le istruzioni di diversi processi, creando l'illusione di esecuzione contemporanea. Su un singolo processore solo un'istruzione alla volta può essere eseguita, ma il SO sospende/riprende processi molto rapidamente.\n\n(2) Supporto al multi-tasking:\nL'interleaving è un meccanismo chiave per il multi-tasking:\n- Il SO può sospendere un processo e passare a un altro molto rapidamente\n- Usa il context switch per salvare lo stato del processo corrente e caricare quello di un altro\n- Crea l'impressione di esecuzione parallela dei processi\n- Migliora l'efficienza complessiva del sistema\n- Consente gestione concorrente di più processi",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "processi-scheduling",
          "multi-tasking",
          "interleaving"
        ]
      },
      {
        "number": 13,
        "text": "(1) Si spieghi l'allocazione della RAM a partizioni contigue e (2) se ne spieghino vantaggi e svantaggi",
        "answer": "(1) Allocazione contigua RAM:\nMetodo dove ogni processo viene caricato in un'unica sezione di memoria contigua. La RAM è divisa in due parti: SO e processi utente. Il meccanismo è \"a partizioni multiple\". Quando un processo deve essere caricato, il SO cerca una porzione libera sufficientemente grande.\n\nCriteri di scelta:\n- Best-fit: la porzione più piccola tra quelle sufficienti\n- First-fit: la prima porzione sufficiente trovata\n- Worst-fit: la porzione più grande tra quelle libere\n\n(2) Vantaggi e svantaggi:\nVantaggi:\n- Semplicità di implementazione e gestione\n- Efficienza: accesso veloce alla memoria (dati contigui)\n\nSvantaggi:\n- Frammentazione esterna: memoria frammentata in piccoli buchi inutilizzabili\n- Limitata flessibilità: dimensione processo limitata dal buco più grande disponibile\n- Compattazione: necessaria per ridurre frammentazione, operazione costosa\n\nDistinzione frammentazione:\n- Esterna: parti libere non contigue, inutilizzabili per processi che richiedono spazio contiguo\n- Interna: parti molto piccole praticamente inutilizzabili",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "topics": [
          "memoria-primaria",
          "allocazione-memoria",
          "frammentazione"
        ]
      }
    ]
  },
  {
    "id": "esame-uuid-misto-domande-varie",
    "date": "2024.00.00",
    "course": "Mixed",
    "title": "Domande Varie - Mix Argomenti (10 domande + template per 40)",
    "topics": [
      "generalita",
      "processi-scheduling",
      "sincronizzazione",
      "memoria-primaria",
      "memoria-massa",
      "file-system"
    ],
    "questions": [
      {
        "number": 1,
        "text": "Nello Unix, quale/quali dei seguenti comandi modifica il valore del link counter dell'index-node associato al file cartella X? (si assuma di avere i permessi per eseguire tutti i comandi e di essere posizionati dentro a X)",
        "answer": "La risposta corretta è: il comando 3) mkdir Z",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "il comando 1) ln X Y",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "i comandi 2) ln -s X W e 4) ls -l . Y",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "il comando 3) mkdir Z",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "i comandi 1) e 3)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "01adf582-af9e-445f-a475-257aeddc19df.jpg"
      },
      {
        "number": 2,
        "text": "Si consideri un sistema con TLB, in cui ciascun accesso alla RAM richiede 200 unità di tempo, l'hit ratio è 90% e ciascun accesso al TLB richiede 10 unità di tempo. Dire se i seguenti valori sono veri o falsi",
        "answer": "Parzialmente corretta. Punteggio ottenuto 1.60/2.00",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "statements": [
          {
            "text": "in caso di TLB miss l'accesso al dato richiede 210 unità di tempo",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB hit l'accesso al dato richiede 210 unità di tempo",
            "isCorrect": true
          },
          {
            "text": "il TLB miss è pari al 5%",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB miss l'accesso al dato richiede 410 unità di tempo",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB hit l'accesso al dato richiede 420 unità di tempo",
            "isCorrect": true
          }
        ],
        "imageRef": "021d8651-e6da-42e0-8443-50af80bc1ba2.jpg"
      },
      {
        "number": 3,
        "text": "Confrontando le librerie statiche e quelle dinamiche possiamo dire che:",
        "answer": "Risposta non ancora data",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "le librerie dinamiche sono sicuramente preferibili a quelle statiche, ad esempio perché al contrario di quelle statiche possono essere usate con la memoria virtuale, e in caso di aggiornamento non costringono alla ricompilazione dei processi che le usano",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "le librerie dinamiche sono sicuramente preferibili a quelle statiche, ad esempio perché vengono caricate in RAM solo se effettivamente usate dai processi, e perché quelle statiche possono essere usate solo col codice dinamicamente rilocabile",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "le librerie dinamiche sono sicuramente preferibili a quelle statiche, ad esempio perché vengono caricate in RAM solo se effettivamente usate dai processi, e in caso di aggiornamento non costringono alla ricompilazione dei processi che le usano",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "le librerie dinamiche sono sicuramente preferibili a quelle statiche, ad esempio perché vengono caricate in RAM solo se effettivamente usate dai processi, e al contrario di quelle statiche possono essere usate col codice dinamicamente rilocabile",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "10ef6b5b-b45f-45ef-85cf-262b6c798d46.jpg"
      },
      {
        "number": 4,
        "text": "In un sistema operativo che adotta uno scheduling senza diritto di prelazione, quattro processi arrivano al tempo indicato e consumano la quantità di CPU indicata nella tabella sottostante. Quali sono il waiting time e il turnaround time medi ottenuti per lo scheduling dei quattro processi della tabella se si usa l'algoritmo di scheduling non preemptive che fornisce le migliori previsioni possibili? Qual è il corrispondente diagramma di GANTT?",
        "answer": "Risposta non ancora data",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pb ... (10). Waiting time medio = 7/4. Turnaround time medio = 17/4",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pb ... (7) ... Pc ... (9) ... Pd ... (10). Waiting time medio = 7/4. Turnaround time medio = 17/4",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pb ... (10). Waiting time medio = 2/4. Turnaround time medio = 18/4",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pd ... (5) ... Pc ... (7) ... Pb ... (10). Waiting time medio = 7/4. Turnaround time medio = 18/4",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "11662c51-07bd-45f3-a64c-703a89e78f14.jpg"
      },
      {
        "number": 5,
        "text": "Di un sistema paginato si sa che lo spazio di indirizzamento logico è grande 1 Gigabyte, e un frame è grande 0x800 byte. Si sa inoltre che la PT più grande del sistema occupa 1 Megabyte. Quanto può essere grande al massimo, lo spazio di indirizzamento fisico del sistema?",
        "answer": "Risposta errata selezionata",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "La PT più grande del sistema contiene 2^19 entry, e viene usato 1 byte per scrivere il numero di un frame. Dunque lo spazio fisico può essere grande al massimo 128 Megabyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "La PT più grande del sistema contiene 2^26 entry, e vengono usati 4 byte per scrivere il numero di un frame. Dunque lo spazio fisico può essere grande al massimo 256 Megabyte",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "La PT più grande del sistema contiene 2^19 entry, e vengono usati 2 byte per scrivere il numero di un frame. Dunque lo spazio fisico può essere grande al massimo 128 Megabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "La PT più grande del sistema contiene 2^18 entry, e vengono usati 2 byte per scrivere il numero di un frame. Dunque lo spazio fisico può essere grande al massimo 256 Megabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "13732e96-d264-4a78-b451-fa3da2c0a70a.jpg"
      },
      {
        "number": 6,
        "text": "Un sistema ha un tempo di accesso in RAM di 80 ns, adotta un TLB con un tempo di accesso di 20 ns e un hit rate del 95%, e usa un algoritmo di rimpiazzamento delle pagine. Quando si verifica un hit la pagina indirizzata è sicuramente in RAM. Quando si verifica un miss, nel 20% dei casi la pagina indirizzata non è in RAM e il page fault ha un costo totale di gestione di 1 microsecondo, indipendentemente dal valore del dirty bit. Qual è l'effective access time (eat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB, e in caso di page fault si consideri solo il tempo di gestione del page fault)",
        "answer": "Risposta non ancora data",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "eat = 116,4 ns",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "eat = 111,4 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "eat = 121,4 ns",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "eat = 126,4 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "d",
        "imageRef": "1902c104-7d38-4ed6-a2b7-ad2c556852f5.jpg"
      },
      {
        "number": 7,
        "text": "Completare il seguente codice in cui viene cercato l'elemento minimo di un array. Completare il codice avendo l'accortezza di non inserire spazi bianchi non necessari.",
        "answer": "Tempo stimato: 4 min (esercizio corretto), 3 min (prossimi esercizi)",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "1cab96b6-41ae-460a-81be-fbae43957f1e.jpg"
      },
      {
        "number": 8,
        "text": "Supponiamo che in un sistema in cui la pagina vittima è scelta con algoritmo di seconda chance migliorato, la lista delle pagine caricate (e relativi bit di riferimento) sia la seguente: p1 (1) → p2 (1) → p3 (0) → p4 (0) → p5 (1). Supponendo di partire da p1, quali sono la configurazione della lista e la vittima identificata, dopo la passata dell'algoritmo?",
        "answer": "Algoritmo seconda chance - pagina replacement",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "p1 (VITTIMA) → p2 (0) → p3 (0) → p4 (0) → p5 (0)",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "p1 (0) → p2 (0) → p3 (0) → p4 (0) → p5 (VITTIMA)",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "p1 (0) → p2 (0) → p3 (VITTIMA) → p4 (0) → p5 (1)",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "p1 (1) → p2 (1) → p3 (VITTIMA) → p4 (0) → p5 (1)",
            "isCorrect": false
          },
          {
            "id": "e",
            "text": "p1 (VITTIMA) → p2 (1) → p3 (0) → p4 (0) → p5 (1)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "26fc8f2f-59e7-4b1f-96f3-abcb63bf61d7.jpg"
      },
      {
        "number": 9,
        "text": "In un sistema operativo un indirizzo fisico è scritto su 28 bit, l'offset più grande in una pagina è 3FFF, lo spazio logico è il doppio di quello fisico, e nel sistema possono essere presenti al massimo 1024 processi. Se il sistema adottasse una Inverted Page Table, quanto sarebbe grande questa tabella? (selezionare l'opzione di risposta che riporta il ragionamento aritmetico e il risultato corretti)",
        "answer": "Risposta corretta. Inverted Page Table calculation",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "Ogni entry della IPT è grande 25 bit, arrotondati a 4 byte, e dunque la IPT sarà grande 4 * 2^14 = 64 Kbyte (circa)",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "Ogni entry della IPT è grande 24 bit, ossia 3 byte, e dunque la IPT sarà grande 3 * 2^15 = 96 Kbyte (circa)",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "Ogni entry della IPT è grande 25 bit, arrotondati a 4 byte, e dunque la IPT sarà grande 4 * 2^15 = 128 Kbyte (circa)",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "Ogni entry della IPT è grande 24 bit, ossia 3 byte, e dunque la IPT sarà grande 3 * 2^14 = 48 Kbyte (circa)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "3395c851-c25e-43cf-a9ea-ee6c624da2f6.jpg"
      },
      {
        "number": 10,
        "text": "In quale caso l'accesso in lettura ad un file memorizzato su un sistema RAID è più veloce che se il file fosse memorizzato su un normale hard disk?",
        "answer": "Risposta salvata",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "sempre, dato che i sistemi RAID sono stati pensati proprio per fornire maggiore velocità di accesso ai file (oltre che maggiore affidabilità)",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "quando il file è memorizzato su due o più blocchi appartenenti a strip contenuti su dischi diversi del RAID",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "quando il file è memorizzato su uno più blocchi appartenenti a strip contenuti sullo stesso disco del RAID",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "quando il RAID usato è di tipo 01/10, poiché in questo caso si possono sfruttare i dischi di mirroring",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "368d187d-dae2-4cdc-8e6b-ec037d3f4332.jpg"
      },
      {
        "number": 11,
        "text": "Un hard disk grande 512 Gigabyte, per scrivere il numero di un blocco vengono usati 28 bit, arrotondati al minimo numero di byte necessario. L'hard disk adotta una allocazione indicizzata semplice, e di un file A si sa che nel suo blocco indice 12 byte vengono usati per tenere traccia dei blocchi di dati di A. Quanto può essere grande al massimo A?",
        "answer": "Risposta non ancora data. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "16 Kilobyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "20 Kilobyte",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "24 Kilobyte",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "28 Kilobyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "3da2b583-773f-461f-afdb-023bddacd2d2.jpg"
      },
      {
        "number": 12,
        "text": "Un sistema ha un tempo di accesso in RAM di 120 ns, adotta un TLB con un tempo di accesso di 10 ns e un hit rate del 95%, usa una paginazione a due livelli e non ha bisogno di usare un algoritmo di rimpiazzamento delle pagine. Qual è il tempo medio di accesso alla RAM (medium access time - mat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB)",
        "answer": "Risposta errata. La risposta corretta è: mat = 141,5 ns",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "mat = 141,5 ns",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "mat = 135,5 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "mat = 130,5 ns",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "mat = 147,5 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "472f4c7c-360e-47e3-9ecd-e610e2c83afb.jpg"
      },
      {
        "number": 13,
        "text": "Completare il seguente codice C per allocare una linked list. Inserire i valori corretti negli spazi vuoti evidenziati.",
        "answer": "Codice per allocazione linked list",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "5072467d-2dbe-40a6-b174-103603dcde75.jpg"
      },
      {
        "number": 14,
        "text": "Spiegare cosa sono, come sono composti e a che cosa servono i grafi di assegnazione delle risorse con archi di reclamo",
        "answer": "Domanda 13 Completo. Punteggio ottenuto: non visibile",
        "maxPoints": 3,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "5fdc652f-af64-4c7d-822f-b19dda329676.jpg"
      },
      {
        "number": 15,
        "text": "Su un hard disk che adotta una allocazione concatenata (senza FAT) è memorizzato un file A della dimensione di 0x8000 byte, e si sa che nell'ultimo blocco di A sono presenti 64 byte del file. Si sa inoltre che per scrivere il numero di un blocco vengono usati 27 bit, arrotondati al minimo numero di byte necessario. Quanto è grosso l'hard disk?",
        "answer": "Domanda 9. Risposta salvata. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "256 Gigabyte",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "512 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "1 Terabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "128 Gigabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "61ba6f4a-3af9-465a-a401-5c5b506a790c.jpg"
      },
      {
        "number": 16,
        "text": "Dopo l'esecuzione dei seguenti comandi in un ambiente Unix (come visti a lezione): 1: cd /tmp, 2: mkdir newfolder, 3: echo 'ciao' > pippo // crea un nuovo file di nome pippo contenente la stringa ciao, 4: cd newfolder, 5: ln ../pippo paperino, 6: ln -s /tmp/newfolder folder2, 7: ln -s paperino topolino, 8: echo 'salve' >> topolino // aggiunge 'salve' a fondo file, 9: rm pippo, 10: cat paperino // cat stampa il contenuto del file passato come argomento, 11: mkdir ../folder3. Scegli un'alternativa:",
        "answer": "Domanda 1. Risposta non ancora data. Punteggio max: 2.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di tmp è: 2, l'output del comando 10 è: 'ciao', il comando 8 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di tmp è: 2, l'output del comando 10 è: no such file or directory, il comando 8 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "il link-counter dell'i-node di paperino è: 1, il link counter di tmp è: 1, l'output del comando 10 è: 'ciao' seguito da 'salve', il comando 8 dà come risultato: un errore perché non sono ammessi hard link tra cartelle",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "il link-counter dell'i-node di paperino è: 1, il link counter di tmp è: aumentato di 2, l'output del comando 10 è: 'ciao', il comando 8 dà come risultato: un nuovo collegamento alla cartella newfolder",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "62578b9e-ed65-467c-90d7-ef79cd114ea6.jpg"
      },
      {
        "number": 17,
        "text": "A un processo P vengono assegnati x frame inizialmente vuoti, e il processo ha una stringa di riferimento lunga y contenente riferimenti a k pagine diverse. Assumendo una paginazione su richiesta pura, e una allocazione locale, qual è il numero massimo di page fault generati da P, e perché?",
        "answer": "Domanda 5. Risposta errata. La risposta corretta è: y page fault",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "x page fault. Infatti, gli x frame sono inizialmente vuoti, e dunque vanno man mano riempiti fino ad arrivare a regime con tutti i frame occupati da pagine del processo",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "y page fault. Questo valore si ottiene quando ogni riferimento ad una qualsiasi pagina di P produce page fault, ossia quando al processo vengono assegnati x=1 frame",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "k page fault. Questo valore si ottiene osservando che ogni riferimento ad una nuova pagina deve per forza produrre un page fault, e se vengono riferite k pagine diverse, si produrranno al massimo k page fault",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "(y + k) page fault. Questo valore si spiega osservando che una stessa pagina può essere riferita più volte non consecutivamente e ogni volta potrebbe generare un page fault, quando al processo vengono assegnati x=1 frame",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "685d043f-3705-449d-beb3-641a9b165bfd.jpg"
      },
      {
        "number": 18,
        "text": "Dopo l'esecuzione dei seguenti comandi in un ambiente Unix: 1: cd /tmp, 2: mkdir newfolder, 3: echo 'ciao' > pippo // crea un nuovo file di nome pippo contenente la stringa ciao, 4: cd newfolder, 5: ln ../pippo paperino, 6: ln -s /tmp/newfolder folder2, 7: cp paperino topolino, 8: echo 'salve' >> topolino // aggiunge 'salve' a fondo file, 9: rm pippo, 10: cat paperino // cat stampa il contenuto del file passato come argomento, 11: mkdir folder3. Scegli un'alternativa (visibile solo opzione b con checkmark):",
        "answer": "Punteggio max: 2.0 su 2.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di newfolder è: 2, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 1",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di newfolder è: 3, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 1",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "Opzione c (non completamente visibile nell'immagine)",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "Opzione d (non completamente visibile nell'immagine)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "6bc9f5a4-f54c-4f57-b9d1-aa43e477425e.jpg"
      },
      {
        "number": 19,
        "text": "Completare il seguente codice C per trovare il massimo in un array. Nel codice manca il ciclo for corretto. Quale deve essere il ciclo for?",
        "answer": "Codice C - trovare massimo array con puntatori",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "72ee6025-4276-4803-8664-51a7649e92ec.jpg"
      },
      {
        "number": 20,
        "text": "In un sistema time sharing che usa un algoritmo di sostituzione delle pagine, tra le ragioni per cui si può verificare un context switch tra processi orienti troviamo:",
        "answer": "Domanda 9. Risposta non ancora data. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "1. il processo in esecuzione ha eseguito una wait su un semaforo con valore < 0, 2. è stata indirizzata una pagina non in memoria primaria da parte del processo running, 3. è appena stato terminato un processo che ha generato una trap, 4. è stata richiesta una operazione di I/O da parte di un processo in coda di ready",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "1. il processo in esecuzione ha eseguito una wait su un semaforo con valore > 0, 2. è stata indirizzata una pagina non in memoria primaria da parte del processo running, 3. è appena stato terminato un processo che ha generato una trap, 4. è stata richiesta una operazione di I/O da parte del processo in CPU",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "1. è stata indirizzata una pagina non in memoria primaria da parte del processo running, 2. il processo in esecuzione ha eseguito una wait su un semaforo con valore < 0, 3. è stata richiesta una operazione di I/O da parte del processo in CPU, 4. è appena stato terminato un processo che ha generato una trap",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "1. il processo in esecuzione ha eseguito una wait su un semaforo con valore < 0, 2. è stata indirizzata una pagina vittima da parte del processo running, 3. è appena stato terminato un processo che ha generato una trap, 4. è stata richiesta una operazione di I/O da parte di un processo in coda di ready",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "73b2f78b-390f-4cb5-8aae-4adab45b9cb8.jpg"
      },
      {
        "number": 21,
        "text": "Completare il seguente codice C che contiene errori nella gestione della memoria dinamica con malloc. Identificare gli errori nel codice.",
        "answer": "Domanda 5 Completo - Codice malloc con errori",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "7479603b-02d8-47e7-9966-faf5acfba5ad.jpg"
      },
      {
        "number": 22,
        "text": "In un sistema operativo che adotta uno scheduling senza diritto di prelazione, quattro processi arrivano al tempo indicato e consumano la quantità di CPU indicata nella tabella sottostante (Pa: 0,4 - Pb: 2,3 - Pc: 3,5 - Pd: 5,1). Quali sono il waiting time e il turnaround time medi ottenuti per lo scheduling dei quattro processi della tabella se si usa l'algoritmo di scheduling non preemptive che fornisce le migliori previsioni possibili? Qual è il corrispondente diagramma di GANTT?",
        "answer": "Domanda 12. Risposta non ancora data. Punteggio max: 2.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pb ... (10). Waiting time medio = 7/4. Turnaround time medio = 17/4",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pb ... (7) ... Pc ... (9) ... Pd ... (10). Waiting time medio = 7/4. Turnaround time medio = 17/4",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pc ... (6) ... Pd ... (7) ... Pb ... (10). Waiting time medio = 2/4. Turnaround time medio = 18/4",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "Diagramma di GANTT: (0) ... Pa ... (4) ... Pd ... (5) ... Pc ... (7) ... Pb ... (10). Waiting time medio = 7/4. Turnaround time medio = 18/4",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "7bd34d3e-0881-4bb6-bfc2-2b46f66638fc.jpg"
      },
      {
        "number": 23,
        "text": "Date le seguenti dichiarazioni: char * s = '123456789'; char * p; cosa viene stampato da seguente codice? p = s+3; printf('%c', *(p+4));",
        "answer": "Tempo stimato: 2 min - Puntatori in C",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "7d3c4a85-fb17-4816-a2dd-a897204703a3.jpg"
      },
      {
        "number": 24,
        "text": "Scrivere nello spazio sottostante il risultato della esecuzione delle due chiamate alla funzione printf(). char *names[] = { 'Huey', 'Dewey', 'Louie', 'Donald Duck'}; void *ptr; ptr = *(names+2); printf('%s ', (char *)ptr ); printf('%s', (char *)ptr+2 );",
        "answer": "Tempo stimato: 2 min - Array di stringhe e puntatori",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "82f4c8c5-5014-4d1d-bcb2-11de94b8eb8c.jpg"
      },
      {
        "number": 25,
        "text": "Di un sistema è noto che la tabella delle pagine più grande del sistema occupa esattamente un frame, il numero di un frame è scritto su 8 byte usando però solo i primi 20 bit, la frammentazione interna media prodotta da un processo del sistema è di circa 32 Kilobyte. Quanto sono grandi lo spazio di indirizzamento fisico e logico del sistema? (selezionare l'opzione di risposta che riporta il ragionamento aritmetico e il risultato corretti)",
        "answer": "Domanda 15. Risposta errata. La risposta corretta è: opzione b (512 MB logico, 64 GB fisico)",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "La tabella delle pagine più grande del sistema ha 2^15/8 entry, e dunque lo spazio logico del sistema è grande 128 Megabyte. Lo spazio fisico è suddiviso in 2^20 frame, e dunque ha una dimensione di 32 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "La tabella delle pagine più grande del sistema ha 2^16/8 entry, e dunque lo spazio logico del sistema è grande 512 Megabyte. Lo spazio fisico è suddiviso in 2^20 frame, e dunque ha una dimensione di 64 Gigabyte",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "La tabella delle pagine più grande del sistema ha 2^16/2 entry, e dunque lo spazio logico del sistema è grande 4 Gigabyte. Lo spazio fisico è suddiviso in 2^20 frame, e dunque ha una dimensione di 64 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "La tabella delle pagine più grande del sistema ha 2^16/2 entry, e dunque lo spazio logico del sistema è grande 4 Gigabyte. Lo spazio fisico è suddiviso in 2^20 frame, e dunque ha una dimensione di 1 Megabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "8cbb2a62-434c-48f3-a019-f71217896afd.jpg"
      },
      {
        "number": 26,
        "text": "Quale valore viene stampato dall'esecuzione del seguente codice? (aggiungere eventuali altre considerazioni nella risposta). Codice find_max con array di double.",
        "answer": "Domanda 5 Completo - Punteggio max: 2. Risposta: 12.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "91819a28-1d4c-41c4-a4c5-4065796a8f78.jpg"
      },
      {
        "number": 27,
        "text": "Data la seguente macro parametrica: #define PLUS2(x) x+2, si dica quale numero viene stampato dal seguente codice: printf('%d\\n', PLUS2(6)*PLUS2(7));",
        "answer": "Domanda 3. Risposta errata. Punteggio ottenuto: 0 su 2",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "94b33657-e158-4bba-9620-b6b7e51c9ae9.jpg"
      },
      {
        "number": 28,
        "text": "Un sistema ha un tempo di accesso in RAM di 120 ns, adotta un TLB con un tempo di accesso di 10 ns e un hit rate del 95%, usa una paginazione a due livelli e non ha bisogno di usare un algoritmo di rimpiazzamento delle pagine. Qual è il tempo medio di accesso alla RAM (medium access time - mat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB)",
        "answer": "Domanda 10. Risposta errata. La risposta corretta è: mat = 141,5 ns",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "mat = 141,5 ns",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "mat = 135,5 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "mat = 130,5 ns",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "mat = 147,5 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "9a281d21-9e85-470d-8f74-a540c03cffa4.jpg"
      },
      {
        "number": 29,
        "text": "L'hard disk di un sistema operativo Unix ha la dimensione di 512 Gigabyte ed è suddiviso in blocchi della dimensione di 0x1000 byte. Di un file A si sa che, una volta in RAM i suoi attributi, incluso il numero del suo index-node, sono necessarie 4 operazioni di I/O per leggere l'ultimo byte del file. Qual è la dimensione minima di A?",
        "answer": "Unix file system - single/double indirect pointers",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "Il file è grande almeno 10*2^12+1 byte. Infatti, le quattro operazioni di I/O richieste implicano che per memorizzare A si sia fatto ricorso al puntatore single indirect, e che nel caso minimo l'ultimo blocco del file contenga un solo byte.",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "Il file è grande almeno 10*2^12+2^22+1 byte. Infatti, le quattro operazioni di I/O richieste implicano che per memorizzare A si sia fatto ricorso al puntatore double indirect, e che nel caso minimo l'ultimo blocco del file contenga un solo byte.",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "Il file è grande almeno 10*2^13+1 byte. Infatti, le quattro operazioni di I/O richieste implicano che per memorizzare A si sia fatto ricorso al puntatore single indirect, e che nel caso minimo l'ultimo blocco del file contenga un solo byte.",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "Il file è grande almeno 10*2^13+2^24+1 byte. Infatti, le quattro operazioni di I/O richieste implicano che per memorizzare A si sia fatto ricorso al puntatore double indirect, e che nel caso minimo l'ultimo blocco del file contenga un solo byte.",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "9df0a867-aa10-4b7d-abc5-4c9c7344b879.jpg"
      },
      {
        "number": 30,
        "text": "Completare il seguente codice C per trovare il minimo di un array. Fornire i valori mancanti: tipo di ritorno della funzione, parametro corretto per sizeof, e parametro corretto per find_min.",
        "answer": "Tempo stimato: 3 min - Codice C trovare minimo",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "9e0ebc58-b543-46a8-a73d-7cdfc739b4b9.jpg"
      },
      {
        "number": 31,
        "text": "In un sistema operativo un indirizzo fisico è scritto su 32 bit, l'offset più grande in una pagina è 3FFF, e lo spazio logico è il doppio di quello fisico. Se il sistema adottasse una Inverted Page Table della dimensione di 1024 Kilobyte, quanti potrebbero essere al massimo i processi presenti contemporaneamente nel sistema?",
        "answer": "Domanda 5. Risposta non ancora data. Punteggio max: 2.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "2^19 processi",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "2^16 processi",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "2^22 processi",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "2^13 processi",
            "isCorrect": true
          }
        ],
        "correctAnswer": "d",
        "imageRef": "b0aca99c-eee6-4fc5-a3c8-32d99e63183e.jpg"
      },
      {
        "number": 32,
        "text": "Data la seguente struttura dati: char *family[] = { 'Huey', 'Dewey', 'Louie', 'Donald Duck'}; completare la definizione della variabile 'aux' determinando il tipo della espressione di assegnamento: aux = family+1;",
        "answer": "Domanda 2. Risposta errata. Tempo: 1 min",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "b5d20b6a-a430-4adc-9a9b-f5e13b29d96d.jpg"
      },
      {
        "number": 33,
        "text": "Un sistema ha un tempo di accesso in RAM di 70 ns, adotta un TLB con un tempo di accesso di 10 ns e un hit rate del 95%, usa una paginazione a due livelli e non ha bisogno di usare un algoritmo di rimpiazzamento delle pagine. Qual è il tempo medio di accesso alla RAM (medium access time - mat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB)",
        "answer": "Domanda 2. Risposta errata. Punteggio ottenuto: -0,5 su 1,0. La risposta corretta è: mat = 86,5 ns",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "mat = 83 ns",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "mat = 90 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "mat = 86,5 ns",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "mat = 80 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "bced584d-a8de-43cb-aee8-f6a358337db1.jpg"
      },
      {
        "number": 34,
        "text": "Secondo quanto visto a lezione, quale/quali dei seguenti comandi Unix modifica il valore del link counter dell'index-node associato al file di testo X? (si assuma di avere i permessi per eseguire tutti i comandi e di essere posizionati in una generica cartella user/tmp che contiene X). 1) ln X .../X, 2) cp X Y, 3) ln X X, 4) rm X Y",
        "answer": "Domanda 7. Risposta non ancora data. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "i comandi 3) e 4)",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "i comandi 1) e 4)",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "i comandi 2) e 3)",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "i comandi 1) e 3)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "be5b0578-83db-4032-b667-4c03acc471fc.jpg"
      },
      {
        "number": 35,
        "text": "Supponiamo che in un sistema in cui la pagina vittima è scelta con algoritmo di seconda chance migliorato, la lista delle pagine caricate (e relativi bit di riferimento e di modifica) sia la seguente: p1 (1,1); p2 (1,0); p3 (0,0); p4 (0,1); p5 (0,-1). Quali pagine NON vengono scelte come vittime?",
        "answer": "Domanda 6. Risposta corretta. Punteggio ottenuto: 2,00 su 2,00",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "statements": [
          {
            "text": "p5 non è scelta",
            "isCorrect": true
          },
          {
            "text": "p4 non è scelta",
            "isCorrect": true
          },
          {
            "text": "p3 è scelta",
            "isCorrect": true
          },
          {
            "text": "p2 non è scelta",
            "isCorrect": true
          },
          {
            "text": "p1 non è scelta",
            "isCorrect": true
          }
        ],
        "imageRef": "c33e846b-0eb6-4d46-b1a1-b90535495cc0.jpg"
      },
      {
        "number": 36,
        "text": "Si consideri questa variante del problema dei produttori e consumatori: Semaphore full =0; empty =N; con codice consumatore e produttore che usano wait e signal. Questa soluzione funziona? Se sì, a quali condizioni? Se no, perché?",
        "answer": "Domanda 3. Risposta non ancora data. Punteggio max: 2.0",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "La soluzione proposta funziona, e corrisponde al caso in cui sono presenti un solo produttore e un solo consumatore, visto che manca il semaforo di mutua esclusione",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "La soluzione proposta funziona a condizione che produttori e consumatori accedano al buffer condiviso i momenti diversi, visto che manca il semaforo di mutua esclusione",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "La soluzione proposta non funziona, visto che manca il semaforo di mutua esclusione e quindi due processi potrebbero accedere al buffer contemporaneamente",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "La soluzione proposta non funziona in nessun caso, perché i semafori coinvolti nelle operazioni di sincronizzazione non sono usati in modo corretto",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "c404653a-679c-41a6-bdba-f25c8750242c.jpg"
      },
      {
        "number": 37,
        "text": "Un sistema operativo moderno adotta un algoritmo di sostituzione delle pagine per: Scegli un'alternativa:",
        "answer": "Domanda 10. Risposta salvata. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "stabilire quale, tra le pagine dei processi utente correntemente in RAM possa essere rimossa per fare spazio ad una pagina mancante che è stata indirizzata da un processo in esecuzione. E' obbligatorio che la pagina scelta sia una pagina che non serve più al processo a cui appartiene, e che non sia stata riferita di recente.",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "stabilire quale, tra le pagine dei processi utente correntemente in RAM possa essere rimossa per fare spazio ad una pagina mancante che è stata indirizzata da un processo in esecuzione. E' auspicabile che la pagina scelta sia una pagina che non serve più al processo a cui appartiene, o almeno che non sia stata riferita di recente.",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "stabilire quale, tra le pagine dei processi utente correntemente in RAM possa essere rimossa per fare spazio ad una pagina più importante che è stata indirizzata da un processo in esecuzione. E' auspicabile che la pagina scelta sia una pagina che non serve più al processo a cui appartiene, o almeno che non sia stata ancora utilizzata.",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "stabilire quale, tra le pagine dei processi utente correntemente in RAM possa essere rimossa per fare spazio ad una pagina più importante che è stata indirizzata da un processo in esecuzione. E' auspicabile che la pagina scelta sia una pagina che non serve più al processo a cui appartiene, o almeno che sia stata riferita di recente.",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "cc2808eb-7ae6-4e0e-88f1-bd80da70955f.jpg"
      },
      {
        "number": 38,
        "text": "Data la seguente struttura dati: char *family[] = { 'Huey', 'Dewey', 'Louie', 'Donald Duck'}; completare la definizione della variabile 'aux' determinando il tipo della espressione di assegnamento: aux = family+1;",
        "answer": "Domanda 2. La risposta corretta è: 22. Risposta giusta è: e' char **",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "cf2ec0e8-2f7f-4e05-b725-a14555bbea69.jpg"
      },
      {
        "number": 39,
        "text": "Dato il seguente codice: int main() { int v; char * p; v = 0xFFFF; p = (char *)&v; p[0] = 1; }. Si dica se il codice è:",
        "answer": "Tempo stimato: 2 min. Il codice è corretto, accede al primo byte di v",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "corretto",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "produce un errore in compilazione",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "potrebbe produrre un errore in esecuzione (Segmentation fault)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "corretto.jpg"
      },
      {
        "number": 40,
        "text": "Analizzare il seguente codice della funzione sclone che contiene errori. Identificare gli errori presenti nel codice: char *sclone(char *s) { ... clone=malloc(len*sizeof(char)); ... s++; c=*s; ... return clone; }",
        "answer": "Codice sclone con malloc - analisi errori",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "dd939024-fa25-4472-8e58-d1c4d11c213f.jpg"
      },
      {
        "number": 41,
        "text": "Si consideri la seguente definizione di struttura C: struct openfile_instance { int inode_index; int reference_count; long offset; }. Definita la seguente tabella di elementi di tipo struct openfile_instance: #define MAX_OPEN_FILES 100; struct openfile_instance openfile_table[MAX_OPEN_FILES];. Specificare correttamente il tipo delle seguenti variabili affinché coincida con il tipo del valore sulla destra dell'assegnamento: a = openfile_table+1; b = openfile_table[4];. Se l'array è composto dai seguenti dati: openfile_table = [ {8,2,0}, {10,1,44}, {3,18,24} ], cosa stampa la seguente printf: printf('%d\\n', *((int *)(openfile_table+2) + 1));",
        "answer": "Tempo stimato: 4 min. Struct, array e puntatori",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "e0d091db-822a-41b0-b6ce-3883f150fa75.jpg"
      },
      {
        "number": 42,
        "text": "In un sistema operativo un indirizzo fisico è scritto su 28 bit, l'offset più grande in una pagina è 3FFF, lo spazio logico è il doppio di quello fisico, e nel sistema possono essere presenti contemporaneamente al massimo 1024 processi. Se il sistema adottasse una Inverted Page Table, quanto sarebbe grande questa tabella? (selezionare l'opzione di risposta che riporta il ragionamento aritmetico e il risultato corretti)",
        "answer": "Domanda 9. Risposta errata. Punteggio ottenuto: 0,0 su 2,0. La risposta corretta è: opzione c",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "Ogni entry della IPT è grande 24 bit, ossia 3 byte, e dunque la IPT sarà grande 3 * 2^14 = 48 Kbyte (circa)",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "Ogni entry della IPT è grande 24 bit, ossia 3 byte, e dunque la IPT sarà grande 3 * 2^15 = 96 Kbyte (circa)",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "Ogni entry della IPT è grande 25 bit, arrotondati a 4 byte, e dunque la IPT sarà grande 4 * 2^14 = 64 Kbyte (circa)",
            "isCorrect": true
          },
          {
            "id": "d",
            "text": "Ogni entry della IPT è grande 25 bit, arrotondati a 4 byte, e dunque la IPT sarà grande 4 * 2^15 = 128 Kbyte (circa)",
            "isCorrect": false
          }
        ],
        "correctAnswer": "c",
        "imageRef": "e3c47f2c-36a4-46d4-afab-6e7eb8c0235f.jpg"
      },
      {
        "number": 43,
        "text": "Indica quali affermazioni inerenti la comunicazione fra processi sono corrette (le risposte sbagliate segnate per vere danno punteggio negativo):",
        "answer": "IPC - comunicazione tra processi. Solo l'opzione d è corretta",
        "maxPoints": 2,
        "negativePoints": -0.5,
        "type": "multianswer",
        "statements": [
          {
            "text": "due processi che comunicano tramite memoria condivisa debbono conoscere l'uno l'identità dell'altro",
            "isCorrect": false
          },
          {
            "text": "le code di messaggi possono avere buffer di capacità 0",
            "isCorrect": false
          },
          {
            "text": "la receive sincrona sospende il mittente del messaggio",
            "isCorrect": false
          },
          {
            "text": "L'accesso incontrollato a una memoria condivisa può rendere i dati inconsistenti",
            "isCorrect": true
          },
          {
            "text": "La capacità del buffer di una coda di messaggi deve crescere secondo le necessità dei processi interagenti",
            "isCorrect": false
          }
        ],
        "imageRef": "e4034446-7099-4f3c-a12d-e4cfb99fb7b0.jpg"
      },
      {
        "number": 44,
        "text": "Su un hard disk che adotta una allocazione concatenata (senza FAT) è memorizzato un file A della dimensione di 0x8000 byte, e si sa che nell'ultimo blocco di A sono presenti 64 byte del file. Si sa inoltre che per scrivere il numero di un blocco vengono usati 27 bit, arrotondati al minimo numero di byte necessario. Quanto è grosso l'hard disk?",
        "answer": "Domanda 8. Risposta salvata. Punteggio max: 1.0",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "1 Terabyte",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "512 Gigabyte",
            "isCorrect": true
          },
          {
            "id": "c",
            "text": "256 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "128 Gigabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "b",
        "imageRef": "e42f3166-6b08-42f5-8236-f03cdd01879e.jpg"
      },
      {
        "number": 45,
        "text": "Di un sistema è noto che la tabella delle pagine più grande del sistema occupa esattamente 2 frame, il numero di un frame è scritto su 8 byte usando però solo i primi 20 bit, e nel sistema sono presenti in media 4 processi che insieme producono una frammentazione interna complessiva di 64 Kilobyte. Quanto sono grandi lo spazio di indirizzamento fisico e logico del sistema?",
        "answer": "Paginazione - calcolo spazi fisico e logico",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "lo spazio logico del sistema è grande 4 Gigabyte, lo spazio fisico del sistema è grande 64 Gigabyte",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "lo spazio logico del sistema è grande 128 Megabyte, lo spazio fisico del sistema è grande 32 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "lo spazio logico del sistema è grande 256 Megabyte, lo spazio fisico del sistema è grande 32 Gigabyte",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "lo spazio logico del sistema è grande 2 Gigabyte, lo spazio fisico del sistema è grande 1 Megabyte",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "e6df3902-2ca0-49f3-b8bf-b1052e06d3fc.jpg"
      },
      {
        "number": 46,
        "text": "Dopo l'esecuzione dei seguenti comandi in un ambiente Unix (come visti a lezione): 1: cd /tmp, 2: mkdir newfolder, 3: echo 'ciao' > pippo // crea un nuovo file di nome pippo contenente la stringa ciao, 4: cd newfolder, 5: ln ../pippo paperino, 6: ln -s /tmp/newfolder folder2, 7: cp paperino topolino, 8: echo 'salve' >> topolino // aggiunge 'salve' a fondo file, 9: rm pippo, 10: cat paperino // cat stampa il contenuto del file passato come argomento, 11: mkdir folder3. Scegli un'alternativa:",
        "answer": "Domanda 4. Risposta errata. La risposta corretta è: opzione d",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di newfolder è: 1, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 2",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di newfolder è: 3, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 1",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "il link-counter dell'i-node di paperino è: 1, il link counter di newfolder è: 3, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 2",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "il link-counter dell'i-node di paperino è: 2, il link counter di newfolder è: 2, l'output del comando 10 è: 'ciao', il link counter di tmp è: aumentato di 1",
            "isCorrect": true
          }
        ],
        "correctAnswer": "d",
        "imageRef": "f746d3e1-2439-4547-b078-c3089c497cbe.jpg"
      },
      {
        "number": 47,
        "text": "Un sistema ha un tempo di accesso in RAM di 100 ns, adotta un TLB con un tempo di accesso di 20 ns e un hit rate del 90%, e usa un algoritmo di rimpiazzamento delle pagine. Quando si verifica un hit la pagina indirizzata è sicuramente in RAM. Quando si verifica un miss, nel 20% dei casi la pagina indirizzata non è in RAM e il page fault ha un costo totale di gestione di 1 microsecondo, indipendentemente dal valore del dirty bit. Qual è l'effective access time (eat) del sistema? (per semplicità in caso di miss si ignori il costo di interrogazione del TLB, e in caso di page fault si consideri solo il tempo di gestione del page fault)",
        "answer": "TLB con page fault - effective access time calculation",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "mat = 144 ns",
            "isCorrect": true
          },
          {
            "id": "b",
            "text": "mat = 128 ns",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "mat = 118 ns",
            "isCorrect": false
          },
          {
            "id": "d",
            "text": "mat = 148 ns",
            "isCorrect": false
          }
        ],
        "correctAnswer": "a",
        "imageRef": "fc1994f8-1655-41ea-8f73-8de2b9aa2459.jpg"
      },
      {
        "number": 48,
        "text": "Si consideri un sistema con TLB, in cui ciascun accesso alla RAM richiede 200 unità di tempo, l'hit ratio è 90% e ciascun accesso al TLB richiede 20 unità di tempo. Dire se i seguenti valori sono veri o falsi:",
        "answer": "TLB - calcolo tempi di accesso. Solo statement 4 è corretto",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "multianswer",
        "statements": [
          {
            "text": "in caso di TLB miss l'accesso al dato richiede 300 unità di tempo",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB hit l'accesso al dato richiede 320 unità di tempo",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB miss l'accesso al dato richiede 400 unità di tempo",
            "isCorrect": false
          },
          {
            "text": "in caso di TLB hit l'accesso al dato richiede 220 unità di tempo",
            "isCorrect": true
          },
          {
            "text": "il TLB miss è pari al 5%",
            "isCorrect": false
          }
        ],
        "imageRef": "fc33830a-2d1b-4687-a59a-5b9ca4ad96bf.jpg"
      },
      {
        "number": 49,
        "text": "Sia data la seguente funzione: char * fun(char * s) { int i; if (s == NULL) return NULL; i = *s-'0'; return s+i; }. Cosa viene stampato dal seguente codice? printf('%s\\n', fun('236494'));",
        "answer": "Tempo stimato: 3 min; punteggio: 2. Programmazione C - puntatori",
        "maxPoints": 2,
        "negativePoints": 0,
        "type": "essay",
        "imageRef": "fd77914e-d462-48a6-9626-dafc990dafc8.jpg"
      },
      {
        "number": 50,
        "text": "Dato il seguente codice: #include <stdlib.h>; int main() { int * p; p = malloc(20); p[19] = 6; }. Si dica se il codice è:",
        "answer": "Tempo stimato: 2 min. Malloc alloca 20 byte (5 int), p[19] accede fuori bounds",
        "maxPoints": 1,
        "negativePoints": 0,
        "type": "multiple-choice",
        "options": [
          {
            "id": "a",
            "text": "corretto",
            "isCorrect": false
          },
          {
            "id": "b",
            "text": "produce un errore in compilazione",
            "isCorrect": false
          },
          {
            "id": "c",
            "text": "potrebbe produrre un errore in esecuzione (Segmentation fault)",
            "isCorrect": true
          }
        ],
        "correctAnswer": "c",
        "imageRef": "seg fault.jpg"
      }
    ]
  },
  {
    "id": "2023-06-16",
    "date": "2023.06.16",
    "course": "A",
    "title": "2023.06.16 Prova di C in presenza, corso A",
    "questions": [
      {
        "number": 1,
        "text": "Si considerino delle liste il cui nodo e` costituito dal seguente tipo di dato\ntypedef struct _node {\nint value;\nstruct _node * next;\n} node;Si definisca la funzione con prototipo\nnode * free_between(node * head, int a, int b);\nla quale elimina e dealloca ogni elemento della lista con campo value compreso fra **a** e **b**, estremi inclusi.\nSe per esempio viene passata la seguente lista come argomento:\nhead → 1 → 4 → 10 → 5 → 7 → 9\nallora,  la chiamata free_between(head, 4, 8) restituisce il puntatore alla lista così modificata:\n(valore di ritorno) → 1 → 10 → 9",
        "answer": "Soluzione iterativa\n<div>node * free_between(node * head, int a, int b) {\nnode * curr, * prev;\t\t/* Puntatori per scorrere lista */\ncurr = head;\nprev = NULL;\nwhile (curr != NULL) {\nif (curr->value >= a && curr->value <= b) {\n/* Nodo da eliminare */\nif (prev == NULL) {\n/* Siamo in testa */\ncurr = curr->next;\nfree(head);\nhead = curr;\n} else {\n/* Nodo nel mezzo della lista */\nprev->next = curr->next;\nfree(curr);\ncurr = prev->next;\n}\n} else {\n/* Scorro lista */\nprev = curr;\ncurr = curr->next;\n}\n}\nreturn head;\n}\n</div>\n<!--\nSoluzione ricorsiva\nnode * list_invert(node * l)\n{\nnode * next_inverted;    /* pointer to next inverted list */\nnode *t;           /* temporary pointer to save successor of item */\nif (l == NULL || l->next == NULL)\nreturn l;\nnext_inverted = list_invert(l->next);\nl->next->next = l;\nl->next = NULL;    /* first node becomes last */\nreturn next_inverted;\n}\n-->",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">Si consideri la seguente definizione di tipo:\nstruct string {\nchar *seq;\nint&nbsp;&nbsp; n;\n};<p dir=\"ltr\" style=\"text-align: left;\">dove **seq **è il puntatore al primo carattere di una sequenza (già allocata in memoria) di **n **caratteri.\nSi definisca la seguente funzione:\nstruct string *f(char *a_Cstring[], int length);<p dir=\"ltr\" style=\"text-align: left;\">che opera su array di stringhe-C ed è tale che:\n1. **a_Cstring[]** è un array di **length** elementi, ciascuno dei quali è una stringa C (sequenza di char terminata da zero);\n2. la funzione restituisce un array **a** di **length **elementi di tipo **struct string**;\n3. l'elemento alla posizione **i** dell'array **a** è così fatto:\n&nbsp;&nbsp; **a[i].seq **punta alla sequenza di caratteri che sono **una copia** della stringa **a_Cstring[i]**, priva del carattere terminatore;\n&nbsp;&nbsp; **a[i].n** è la dimensione in caratteri della sequenza.\nAd esempio se:\n&nbsp;&nbsp; &nbsp;a_Cstring -> { \"Hello\", \" \", \"World\", \"!\" }<p dir=\"ltr\" style=\"text-align: left;\">allora la chiamata **f(a_Cstring, 4)** restituisce un array di **struct string** così composto:\n&nbsp;&nbsp; &nbsp;a -> { {\"Hello\",5}, {\" \",1}, {\"World\",5}, {\"!\",1} }",
        "answer": "<pre dir=\"ltr\" style=\"text-align: left;\">struct string *f(char *a_Cstring[], int length){\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp;&nbsp; // array restituito come risultato\n&nbsp;&nbsp;&nbsp; struct string *a = calloc(length, sizeof(struct string));\n&nbsp;&nbsp; &nbsp;// puntatore usato per scorrere per indirizzo gli elementi dell'array risultato\n&nbsp;&nbsp;&nbsp; struct string *e = a;\n&nbsp;&nbsp; &nbsp;// idice usato per scorrere gli elementi dell'array a_Cstring\n&nbsp;&nbsp; &nbsp;int i;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;// ciclo che itera sugli elementi dell'array a_Cstring\n&nbsp;&nbsp;&nbsp; for (i=0 ; i<length; i++, e++){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; int l;&nbsp;&nbsp;&nbsp;&nbsp; // lunghezza stringa corrente in a_Cstring\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; char *end; // puntatore alla posizione che segue l'ultimo elemento\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dell'array a_Cstring (fine array)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; char *str = a_Cstring[i];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; char *ptr;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\nl = str != NULL ? strlen(str) : 0;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; end = str+l;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; e->seq = ptr = malloc(l);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; while (str<end)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *ptr++ = *str++;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; e->n = l;\n&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;return a;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  },
  {
    "id": "2023-06-16",
    "date": "2023.06.16",
    "course": "B",
    "title": "2023.06.16 Prova di C in presenza, corso B",
    "questions": [
      {
        "number": 1,
        "text": "Data una lista **L**<span> di valori</span> numerici interi:\n- sia **M** la sottolista di **L** che inizia dal suo valore massimo e prosegue fino alla sua fine\n- sia **H** la sottolista di **L** che inizia dalla testa fino alla suo valore massimo escluso.\nLa lista **L** e` quindi uguale a **H** → **M**. Si vuole realizzare in C la funzione con prototipo:\nnode * head_is_max(node * head);\nla quale modifichi la lista head in modo che risulti **M** → **H**. Se per esempio viene passata la seguente lista come argomento:\nhead → 1 → 4 → 10 → 5 → 7 → 9\nallora, visto che il valore massimo e` 10,  la chiamata head_is_max(head) restituisce il puntatore alla lista così modificata:\n(valore di ritorno) → 10 → 5 → 7 → 9 → 1 → 4\n**ATTENZIONE**: La funzione DEVE **esclusivamente&nbsp;**agire** sui puntatori**. NON deve quindi ne eliminare nodi, ne crearne di nuovi.\nIl generico nodo della lista e` dichiarato del seguente tipo\ntypedef struct _node {\nint value;\nstruct _node * next;\n} node;",
        "answer": "Soluzione iterativa\n<div><div>node * head_is_max(node * head) {</div><div>        node * curr, * prev;            /* Puntatori per scorrere lista */</div><div>        node * curr_max, * prev_max;    /* Puntatori per ricordare posizione max */</div>\n<div>        curr = curr_max = head;</div><div>        prev = prev_max = NULL;</div><div>        while (curr != NULL) {</div><div>                if (curr->value > curr_max->value) {</div><div>                        /* Trovato valore piu` alto: aggiorno */</div><div>                        curr_max = curr;</div><div>                        prev_max = prev;</div><div>                }</div><div>                /* Scorro la lista */</div><div>                prev = curr;</div><div>                curr = curr->next;</div><div>        }</div><div>        if (curr_max != head) { /* Se non siamo in testa... */</div><div>                /* Richiudo lista su elemento di testa */</div><div>                prev->next = head;</div><div>                /* Chiudo la nuova lista dopo l'ultimo elemento */</div><div>                prev_max->next = NULL;</div><div>        }</div><div>        return curr_max;</div><div>}</div></div>\n<!--\nSoluzione ricorsiva\nnode * list_invert(node * l)\n{\nnode * next_inverted;    /* pointer to next inverted list */\nnode *t;           /* temporary pointer to save successor of item */\nif (l == NULL || l->next == NULL)\nreturn l;\nnext_inverted = list_invert(l->next);\nl->next->next = l;\nl->next = NULL;    /* first node becomes last */\nreturn next_inverted;\n}\n-->",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">Sia data la seguente definizione utilizzata per rappresentare delle stringhe di caratteri:\nstruct string {\nchar *seq;\nint   n;\n};<p dir=\"ltr\" style=\"text-align: left;\">dove il campo **seq **è il puntatore al primo carattere di una sequenza (già allocata in memoria) di **n **caratteri.\nDefinire la funzione **str_cat** dal seguente prototipo:\nstruct string str_cat(struct string a_str[], const int length);<p dir=\"ltr\" style=\"text-align: left;\">la quale:\n1. ha due argomenti, rispettivamente:\n&nbsp;&nbsp; - **a_str[]**: un array di **length** elementi di tipo **struct string**;\n&nbsp;&nbsp; - **length**: il numero di elementi dell'array **a_str[]**.\n**2.** restituisce una variabile di tipo **struct string** che rappresenta la stringa concatenamento delle stringhe memorizzate in **a_str[]**, secondo l'ordine crescente dell'indice.\nAd esempio se:\n&nbsp;&nbsp; &nbsp;a_str -> { {\"Hello\",5}, {\" \",1}, {\"World\",5}, {\"!\",1} }<p dir=\"ltr\" style=\"text-align: left;\">allora la chiamata **str_cat(a_str, 4) **restituisce una **struct string** così composta:\n&nbsp;&nbsp; &nbsp;{\"Hello World!\", 12}",
        "answer": "struct string str_cat(struct string a_str[], const int length){<p dir=\"ltr\" style=\"text-align: left;\">&nbsp;&nbsp;&nbsp; int i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // variabile indice usata per scorrere l'array a_str\n&nbsp;&nbsp; &nbsp;int m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // dimensione totale della stringa risultato della concatenazione\n&nbsp;&nbsp; &nbsp;char *p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // puntatore usato per scorrere i caratteri della sequenza risultato\n&nbsp;&nbsp; &nbsp;struct string r; // struct string risultato (restituita per valore)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;for (m=0,i=0 ; i<length ; i++)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; m += a_str[i].n;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp; &nbsp;r.seq = malloc(sizeof(char)*m);\n&nbsp;&nbsp;&nbsp; r.n = m;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;p = r.seq;\n&nbsp;&nbsp; &nbsp;struct string *e;\n&nbsp;&nbsp; &nbsp;struct string *end;\n&nbsp;&nbsp;&nbsp; for (e=a_str, end=a_str+length&nbsp; ; e<end ; e++){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; *s = e->seq;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; int s_len = e->n;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; char *s_end = s+s_len;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while (s<s_end )\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *p++ = *s++;\n&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp; return r;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  },
  {
    "id": "2023-01-24",
    "date": "2023.01.24",
    "course": "A",
    "title": "2023.01.24 Prova di C in presenza, corso A",
    "questions": [
      {
        "number": 1,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">Siano date le seguenti definizioni di tipo utilizzate per rappresentare delle liste di stringhe C (ovvero sequenze di (char) terminate dallo zero).\n<p dir=\"ltr\" style=\"text-align: left;\">typedef struct _node {\n&nbsp;&nbsp;&nbsp; char * s;\n&nbsp;&nbsp;&nbsp; struct _node * next;\n} node;\nDefinire la funzione dal seguente prototipo:\nchar * concat_from_list(node * head);\nla quale alloca e restituisce una stringa C ottenuta concatenando le stringhe elencate nella lista puntata da head, intervallate dal carattere spazio ' '.\nAd esempio se head è così composta:\n&nbsp;&nbsp; head -> \"Stanno\" -> \"tutti\" -> \"molto bene\"\nallora concat_from_list(head) restituisce la seguente stringa:\n\"Stanno tutti molto bene\"",
        "answer": "<p dir=\"ltr\" style=\"text-align: left;\">/* Versione iterativa: due loop ma una sola malloc della dimensione giusta */\nchar * concat_from_list(node * head)\n{\n&nbsp;&nbsp; &nbsp;char * s_ret;\n&nbsp;&nbsp; &nbsp;unsigned int s_len, i;\n&nbsp;&nbsp; &nbsp;node * p;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;/* Calcola lunghezza totale e poi alloca */\n&nbsp;&nbsp; &nbsp;for (p = head, s_len=0; p; p = p->next)\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; s_len += strlen(p->s)+1;\n&nbsp;&nbsp; &nbsp;s_ret = malloc(s_len);\n&nbsp;&nbsp; &nbsp;s_ret[0] = 0;\n&nbsp;&nbsp; &nbsp;for (p = head; p; p = p->next) {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; strcat(s_ret, p->s);\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; strcat(s_ret, \" \");\n&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;/* Sovrascrivo l'ultimo spazio con lo zero di terminazione */\n&nbsp;&nbsp; &nbsp;s_ret[s_len-1] = 0;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;return s_ret;\n}\n/* Versione ricorsiva: si fanno molte copie, malloc/free */\nchar * concat_from_list(node * head)\n{\n&nbsp;&nbsp; &nbsp;char * s_ret, *s_next;\n&nbsp;&nbsp; &nbsp;unsigned int s_len, new_len, i;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;/* Stringa vuota */\n&nbsp;&nbsp; &nbsp;s_ret = malloc(1);\n&nbsp;&nbsp; &nbsp;s_ret[0] = 0;\n&nbsp;&nbsp; &nbsp;s_len = 0;\n&nbsp;&nbsp; &nbsp;if (head == NULL) {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return s_ret;\n&nbsp;&nbsp; &nbsp;} else {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; Copia stringa: si puo` usare anche strncpy/strcpy */\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; for (i=0; head->s[i] != 0; i++) {\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; s_ret[s_len] = head->s[i];\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; s_ret = realloc(s_ret, (++s_len+1));\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; s_ret[s_len] = 0;\n&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp; &nbsp;/* Invocazione su had->next */\n&nbsp;&nbsp; &nbsp;s_next = concat_from_list(head->next);\n&nbsp;&nbsp; &nbsp;new_len = strlen(s_next);\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;/* Rialloca per vecchia+nuova+spazio+zero di terminazione */\n&nbsp;&nbsp; &nbsp;s_ret = realloc(s_ret, s_len+new_len+2);\n&nbsp;&nbsp; &nbsp;s_ret[s_len] = ' ';\n&nbsp;&nbsp; &nbsp;s_ret[s_len+1] = 0;\n&nbsp;&nbsp; &nbsp;/* Copia stringa: strncat/srtcat e` alternativa a ciclo per copia */\n&nbsp;&nbsp; &nbsp;strncat(s_ret, s_next,new_len);\n&nbsp;&nbsp; &nbsp;free(s_next);&nbsp; /* liberare la stringa s_next prima di uscire */\n&nbsp;&nbsp; &nbsp;return s_ret;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">Sia data la seguente definizione della struttura C 'struct record':\nstruct record {\n&nbsp;&nbsp;&nbsp; char * name;\n&nbsp;&nbsp;&nbsp; unsigned int age;\n};<p dir=\"ltr\" style=\"text-align: left;\">Definire la seguente funzione per dati di tipo **array **di 'struct record':\nstruct record ** minmax_by_age(struct record vec[], unsigned int length);<p dir=\"ltr\" style=\"text-align: left;\">che restituisce un array di **2** puntatori di tipo **(struct record *)**:\n- Il primo elemento dell'array restituito punta un elemento di **vec** con campo \"**age**\" minimo.\n- Il secondo elemento dell'array restituito punta un elemento di **vec** con campo \"**age**\" massimo.\n<p dir=\"ltr\" style=\"text-align: left;\">Per esempio, dopo l'esecuzione del seguente codice\nstruct record v[] = {{\"Adele\", 20}, {\"Bianca\", 12}, {\"Carlo\", 14}};\n...\nminmax_v = minmax_by_age(v, 3);\n<p dir=\"ltr\" style=\"text-align: left;\">Ci aspettiamo che:\n- il campo \"**name**\" di minmax_v[0], sia \"Bianca\", in quanto il suo campo \"age\" e` minimo\n- il campo \"**name**\" di minmax_v[1], sia \"Adele\", in quanto il suo campo \"age\" e` massimo.\nCome di consueto, si scelga l'elemento in modo arbitrario nel caso in cui ci siano piu` elementi con stesso valore minimo/massimo.",
        "answer": "struct record ** minmax_by_age(struct record vec[], unsigned int length)\n{\nstruct record ** ret;\nunsigned int i;\nif (vec == NULL || length <=0)\nreturn NULL;\n/* Inizializzazione */\nret = malloc(2*sizeof(*ret));\nret[0] = ret[1] = vec;\n/* Cerca min e max */\nfor (i=1; i<length; i++){\nif (vec[i].age < ret[0]->age)\nret[0] = vec+i;\nif (vec[i].age > ret[1]->age)\nret[1] = vec+i;\n}\nreturn ret;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "2023-01-24",
    "date": "2023.01.24",
    "course": "B",
    "title": "2023.01.24 Prova di C in presenza, corso B",
    "questions": [
      {
        "number": 1,
        "text": "Sia data la seguente definizione di tipo utilizzata per rappresentare delle liste di valori interi:\ntypedef struct _node {\nint value;\nstruct _node * next;\n} node;Definire la funzione dal seguente prototipo:\nvoid vec_list_cut_leq(node ** vec_head);\nla quale riceve in input un array di liste (ovvero di puntatori di tipo (node *)) terminato da NULL, per esempio\n[head0, head1, head2, NULL]\n**Per **ogni elemento**** \"head\" dell'array, la funzione elimina un elemento della lista puntata da \"head\" se e solo se e` minore o uguale di qualche elemento che lo precede.\nSe per esempio la lista \"head\" di qualche elemento dell'array e`\nhead → 7 → 3 → 9 → 11 → 10 → 11\nallora dopo la chiamata a vec_list_cut_leq, tale lista sara`:\nhead → 7 → 9 → 11",
        "answer": "void vec_list_cut_leq(node ** vec_head) {\nnode *p, *p_next, *aux, *head;\n/* Cicla sugli elementi di vec_head, se non siamo arrivati alla fine */\nfor (; (head = *vec_head) != NULL; vec_head++) {\np = head;\nfor (p_next = p->next; p_next != NULL; p_next = p->next) {\nif (p_next->value <= p->value) {\n/* Elimino elemento p_next */\naux = p_next;\np->next = p_next->next;\nfree(aux);\n} else {\np = p_next;\n}\n}\n}\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "<p dir=\"ltr\" style=\"text-align: left;\">Una lista di array di interi e` implementata attraverso la seguente struct per ogni nodo della lista\ntypedef struct _node {\nint * vec;            /* puntatore all'array */\nunsigned int len;     /* lunghezza dell'array */\n&nbsp;&nbsp;&nbsp; struct _node *next;   /* puntatore per il collegamento dei nodi */<p dir=\"ltr\" style=\"text-align: left;\">} node;\nutilizzata nel seguente modo:\n- il puntatore \"vec\" punta all'indirizzo di memoria sullo heap dove l'array e` allocato (con malloc/calloc)\n- \"len\" e` la lunghezza dell'array\n- next punta al prossimo nodo della lista e vale NULL per l'ultimo elemento\n- un valore len=0 oppure vec=NULL, indicano un array vuoto.\nDefinire la seguente funzione\nvoid print_list(node * head);\nla quale stampa tutti gli elementi della lista di array, andando a capo dopo ogni array.\nAd esempio se \"head\" è così composta:\n&nbsp;&nbsp; head -> [1,2] -> [3] -> [4,5,6,7] -> [8,9] -> [10,11]\nallora viene stampato\n1 2\n3\n4 5 6 7\n8 9\n10 11",
        "answer": "void print_list(node * head) {\nunsigned int i;\nfor (; head != NULL; head = head->next) {\nif (head->vec != NULL)\nfor (i=0; i < head->len; i++)\nprintf(\"%i \", head->vec[i]);\nprintf(\"\\n\");\n}\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  },
  {
    "id": "2022-02-08",
    "date": "2022.02.08",
    "course": "A",
    "title": "2022.02.08 Prova di C in presenza, corso A",
    "questions": [
      {
        "number": 1,
        "text": "Sia data la seguente definizione di tipo utilizzata per rappresentare delle liste di valori interi:\ntypedef struct _node {\nint val;\nstruct _node * next;\n} node;Definire la funzione dal seguente prototipo:node * list_invert(node * head);\nla quale inverte l'ordine degli elementi memorizzati nella lista puntata da head passata come argomento. Se per esempio viene passata la seguente lista come argomento:\nhead → 1 → 2 → 3 → 4\nallora la chiamata list_invert(head) restituisce il puntatore alla lista così modificata:\n(valore di ritorno) → 4 → 3 → 2 → 1\n<b>ATTENZIONE</b>: La funzione non deve allocare una nuova lista nell'ottenere il risultato, ma soltanto scambiare opportunamente i nodi presenti.",
        "answer": "Soluzione iterativa\nnode * list_invert(node * head)\n{\nnode *item = head;  /* current node */\nnode *p = NULL;     /* predecessor of item, NULL if item is head */\nnode *t;            /* temporary pointer to save successor of item */\nwhile (item!=NULL){\nt = item->next;\nitem->next = p;\np = item;\nitem = t;\n}\nreturn p;\n}\nSoluzione ricorsiva\nnode * list_invert(node * head)\n{\nnode * inverted_next;\nif (head == NULL || head->next == NULL)\nreturn head;\ninverted_next = list_invert(head->next);\nhead->next->next = head;\nhead->next = NULL;\nreturn inverted_next;\n}",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "Si definisca una funzione C dal seguente prototipo:\nchar * longest_word(const char * str);\nla quale alloca e restituisce una stringa contenente la parola piu` lunga contenuta all'interno della stringa str passata per parametro. Per \"parola\" si intende una sequenza di caratteri che non contiene lo spazio ' ' (e neppure il byte zero '\\0' di terminazione).",
        "answer": "Esempio di soluzione\nchar* longest_word(const char *str)\n{\nint i, max = -1, cur_len=0;\nchar* res = NULL;\nint offset = 0;\nif(str == NULL)\nreturn NULL;\n/* cerco parola piu` lunga */\nfor(i=0; str[i]!='\\0'; i++){\nif(str[i]==' '){\nif(cur_len > max){\n/* aggiorna lunghezza massima e offset */\nmax = cur_len;\noffset = i - max;\n}\ncur_len = 0;\n} else\ncur_len++;\n}\n/* controllo esplicito ultima parola */\nif(cur_len > max) {\nmax = cur_len;\noffset = i - max;\n}\n/* alloco la memoria se necessario */\nif(max >= 1) {\nres = malloc(max+1);\nmemcpy(res, str+offset, max);\nres[max] = '\\0';\n}\nreturn res;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  },
  {
    "id": "2022-02-08",
    "date": "2022.02.08",
    "course": "B",
    "title": "2022.02.08 Prova di C in presenza, corso B",
    "questions": [
      {
        "number": 1,
        "text": "Sia data la seguente definizione di tipo utilizzata per rappresentare delle liste di valori interi:\ntypedef struct _node {\nint val;\nstruct _node * next;\n} node;Definire la funzione dal seguente prototipo:node * list_trim(node * head);\nla quale elimina e dealloca dalla lista head gli elementi seguenti con lo stesso valore val.\nSe per esempio viene passata la seguente lista come argomento:\nhead → 1 → 1 → 3 → 3 → 3 → 2 → 7 → 4 → 4 → 4\nallora la chiamata list_trim(head) restituisce il puntatore alla lista così modificata:\n(valore di ritorno) → 1 → 3 → 2 → 7 → 4\n<b>ATTENZIONE</b>: La funzione non deve allocare una nuova lista nell'ottenere il risultato.",
        "answer": "Soluzione iterativa\nnode * list_trim(node * head)\n{\nnode * item; /* points to current node */\nnode * p=l;   /* points to the predecessor of item */\nif (p != NULL && (item=p->next)!=NULL) {\nwhile (item!=NULL){\nif ( item->val == p->val ){\np->next = item->next;\nfree(item);\nitem = p->next;\n} else {\np = item;\nitem=item->next;\n}\n}\n}\nreturn head;\n}\n<!--\nSoluzione ricorsiva\nnode * list_invert(node * l)\n{\nnode * next_inverted;    /* pointer to next inverted list */\nnode *t;           /* temporary pointer to save successor of item */\nif (l == NULL || l->next == NULL)\nreturn l;\nnext_inverted = list_invert(l->next);\nl->next->next = l;\nl->next = NULL;    /* first node becomes last */\nreturn next_inverted;\n}\n-->",
        "maxPoints": 5,
        "type": "essay"
      },
      {
        "number": 2,
        "text": "Data la seguente definizione di struttura C\nstruct string {\nchar *s;\nint length;\n};\nper la memorizzazione di stringhe e della loro lunghezza, si definisca una funzione C dal seguente prototipo:\nstruct string * str_array(char *str_cat, int size);\ndove:\n- str_cat: rappresenta una concatenazione in memoria di stringhe C terminate dallo 0. Ad esempio, in\nstr_cat-> \"Unix System V\\0is one of the first Unix\\0operating systems\\0\"str_cat punta ad una concatenazione in memoria di 3 stringhe C così come rappresentate nel testo.\n- size: rappresenta il numero di stringhe nella concatenazione str_cat. Nell'esempio sopra, size ha valore 3.\nLa funzione restituisce un array di 'size' dati di tipo 'struct string' tale che ciascun suo elemento descriva, secondo l'ordine imposto dalla memorizzazione, la stringa corrispondente della concatenazione str_cat:\n- il campo 's' dell'elemento i-esimo dell'array punta alla i-esima stringa nella concatenazione;\n- il campo 'length' dell'elemento i-esimo dell'array è la lunghezza della i-esima stringa nella concatenazione.\nNell'esempio di cui sopra, la funzione restituirebbe un (puntatore ad un) array con\n<ol>- il campo 's' del primo elemento che punta alla sotto-stringa \"Unix System V\"\n- il campo 's' del secondo elemento che punta alla sotto-stringa \"is one of the first Unix\"\n- il campo 's' del terzo (e ultimo) elemento che punta alla sotto-stringa \"operating systems\"\n</ol>mentre i campi length sarebbero rispettivamente i valori: 13, 24, 17.",
        "answer": "Segue esempio di soluzione\nstruct string *str_array(char *str_cat, int size)\n{\nstruct string * sd;\nsd = (struct string *)calloc(size, sizeof(struct string));\nif (str_cat!=NULL){\nchar *s=str_cat;\nint i;\nfor (i=0;i<size;i++){\nsd[i].s = s;\nint length = 0;\nwhile ( *s++ != '\\0' )\nlength++;\nsd[i].length = length;\n}\n}\nreturn sd;\n}",
        "maxPoints": 5,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  },
  {
    "id": "2022-02-05",
    "date": "2022.02.05",
    "course": "A",
    "title": "2022.02.05 Prova di C da remoto",
    "questions": [
      {
        "number": 2,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915612:2_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 4 min]</b>\nSiano date le seguenti definizioni di tipo utilizzate per rappresentare delle liste di valori interi:\ntypedef struct _node { &nbsp;&nbsp;&nbsp; int value;\n&nbsp;&nbsp;&nbsp; struct _node *next;\n} node;\ntypedef node *list;\nLa funzione sul dato di tipo list dal prototipo:\nlist l_del_node(list l, int v)elimina dalla lista l tutti i nodi con campo value uguale a v e restituisce la lista risultato.\nCompletare la seguente definizione ricorsiva della funzione l_del_node nei campi vuoti.<!-- ove vanno poste le chiamate ricorsive.-->\nlist l_del_node(list l, int v) {\n&nbsp;&nbsp;&nbsp; if(l != NULL){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node *succ = l->next;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(l->value == value){\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free(l);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:2_sub1_answer\">Risposta 1 Domanda 2</label><input type=\"text\" name=\"q915612:2_sub1_answer\" id=\"q915612:2_sub1_answer\" size=\"20\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : l_del_node(succ, v)\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> ;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l->next = <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:2_sub2_answer\">Risposta 2 Domanda 2</label><input type=\"text\" name=\"q915612:2_sub2_answer\" id=\"q915612:2_sub2_answer\" size=\"19\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : l_del_node(succ, v)\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> ;\n&nbsp;&nbsp; &nbsp;}\n&nbsp;&nbsp;&nbsp; return l;\n}",
        "answer": "Risposte esatte:\n- parte 1: l_del_node(succ, v)\n- parte 2: l_del_node(succ, v) o anche l_del_node(l->next, v)",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 3,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915612:3_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 3 min]</b>\nSiano date le seguenti definizioni C:\n<img src=\"https://esami.i-learn.unito.it/pluginfile.php/223486/question/questiontext/915612/3/11172982/Capture%20%283%29.PNG\" alt=\"\" role=\"presentation\" class=\"img-responsive atto_image_button_text-bottom\" width=\"503\" height=\"380\">\nSpecificare di che tipo sono le seguenti espressioni C:\n1. &((a.dscr+4)->next);\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:3_sub1_answer\">Risposta 1 Domanda 3</label><input type=\"text\" name=\"q915612:3_sub1_answer\" id=\"q915612:3_sub1_answer\" size=\"20\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : tuple **&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>\n2. &(*(a.dscr+4)).d;\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:3_sub2_answer\">Risposta 2 Domanda 3</label><input type=\"text\" name=\"q915612:3_sub2_answer\" id=\"q915612:3_sub2_answer\" size=\"17\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : weekday * &nbsp; &nbsp; &nbsp;&nbsp;\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>",
        "answer": "Risposte corrette (anche senza le parentesi):\n- parte 1: \"(tuple **)\".\n- \"a\" e` (struct collection)\n- \"a.descr\" e` (tuple *), cosi` come a.descr+4\n- \"(a.dscr+4)->next\" e` (tuple *)\n- \"&((a.dscr+4)->next)\" e` (tuple **)\n- parte 2: \"(weekday *)\"\n- \"(a.dscr+4)\" e` (tuple *), come sopra\n- \"*(a.dscr+4)\" e` (tuple)\n- \"(*(a.dscr+4)).d\" e` (weekday)\n- \"&(*(a.dscr+4)).d\" e` (weekday *)",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 4,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915612:4_:sequencecheck\" value=\"2\">[TEMPO STIMATO: 4 min]\nSiano date le seguenti definizioni C:\n#define TABLE_SIZE 10\nstruct attr {\n&nbsp;&nbsp; &nbsp;int h;&nbsp; // height\n&nbsp;&nbsp;&nbsp; int w;&nbsp; // weigth\n}\nstruct client {\n&nbsp;&nbsp; &nbsp;unsigned int id;&nbsp;&nbsp; // client unique id\n&nbsp;&nbsp; &nbsp;struct attr&nbsp; par;&nbsp; // attributes\n}\nstruct client cls[TABLE_SIZE]; // table of clients\nData le varibili <b>ptr</b> e <b>acc</b> così definite ed inizializzate:\nstruct client *ptr=NULL;\nint acc = 0;\ndove\n- la prima, <b>ptr</b>, è utilizzata per puntare al generico dato di tipo <b>struct </b><b>client </b>della tabella <b>cls</b> mentre\n- la seconda, <b>acc</b>, è utilizzata per accumulare dei valori interi\nrisolvere l'esercizio secondo le seguenti specifiche.\nCompletare il seguente ciclo <b>for </b>iterando sul puntatore <b>ptr</b><b> </b>al fine di accumulare nella variabile <b>acc</b> i valori del campo <b>w</b> della sotto-struttura <b>par</b> di client<b> </b>per tutti i clienti nella tabella <b>cls:</b>\nconst struct client *end = cls+TABLE_SIZE;\nfor (&nbsp;<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:4_sub1_answer\">Risposta 1 Domanda 4</label><input type=\"text\" name=\"q915612:4_sub1_answer\" id=\"q915612:4_sub1_answer\" size=\"9\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : ptr = cls\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>  ;&nbsp;ptr < end ;&nbsp;ptr++){\n&nbsp;&nbsp; &nbsp;acc += <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915612:4_sub2_answer\">Risposta 2 Domanda 4</label><input type=\"text\" name=\"q915612:4_sub2_answer\" id=\"q915612:4_sub2_answer\" size=\"10\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : ptr-&gt;par.w\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> ;\n}",
        "answer": "Ciclo effettuato con il puntatore \"ptr\"\n- parte 1: \"ptr = cls\", \"ptr = &(cls[0])\"\n- parte 2: \"ptr->par.w\"",
        "maxPoints": 2,
        "type": "multianswer"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "2021-07-06",
    "date": "2021.07.06",
    "course": "A",
    "title": "2021.07.06 Prova di C da remoto",
    "questions": [
      {
        "number": 1,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915616:1_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 3 min]</b>\nSia data la seguente definizione di funzione su stringhe C:\ntypedef char * string;\n/* scount(s,c): it counts how many c are in s */\nint scount(string s, char c){\n&nbsp;&nbsp; int cnt=0;\n&nbsp;&nbsp; while (*s!='\\0')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cnt += ( *s++ == c ? 1 ; 0);\n&nbsp;&nbsp; return cnt;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;\n}Data la stringa seguente:\nstring sentence = \"The exam starts at 5.00 pm. The exam will be hosted on the Moodle platform remotely.\";\nCompletare la chiamata alla funzione 'scount' affinché calcoli quanti caratteri\n'm' sono nella seconda frase (\"The exam will be hosted on the Moodle\nplatform remotely.\") della stringa sentence:\nint n = scount(<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:1_sub1_answer\">Risposta 1 Domanda 1</label><input type=\"text\" name=\"q915616:1_sub1_answer\" id=\"q915616:1_sub1_answer\" size=\"11\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : sentence+27\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> , <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:1_sub2_answer\">Risposta 2 Domanda 1</label><input type=\"text\" name=\"q915616:1_sub2_answer\" id=\"q915616:1_sub2_answer\" size=\"3\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : 'm'\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>  );",
        "answer": "- parte 1: sentence+27 (per iniziare a cercare da \" The exam will be\")\n- parte 2: 'm' (carattere da cercare con singoli apici)",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 2,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915616:2_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 4 min]</b>\nSi consideri la seguente definizione di struttura C:\nstruct node {\n&nbsp;&nbsp; &nbsp;int&nbsp; val;\n&nbsp;&nbsp; &nbsp;struct node *next;\n};Si completi la seguente funzione ricorsiva, la quale riceve un array v di n interi e inserisce in testa alla lista puntata da head, una struct node per ogni elemento di v. Il campo val dell'elemento della lista inserito in posizione i, deve valere v[i].\nPer esempio, se vengono passati:\nv = {4, 2, 6, 9};\nhead -> 8 -> 5\nallora la lista ritornata dovra` essere\nhead -> 4 -> 2 -> 6 -> 9 -> 8 -> 5\nstruct node * ins_array_list(int v[], int n, struct node * head) {\nstruct node * p;\nif (n==0)\nreturn head;\np = malloc(sizeof(struct node));\np->val = v[0];\np->next = ins_array_list(<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:2_sub1_answer\">Risposta 1 Domanda 2</label><input type=\"text\" name=\"q915616:2_sub1_answer\" id=\"q915616:2_sub1_answer\" size=\"3\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : v+1\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>,<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:2_sub2_answer\">Risposta 2 Domanda 2</label><input type=\"text\" name=\"q915616:2_sub2_answer\" id=\"q915616:2_sub2_answer\" size=\"3\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : n-1\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>,<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:2_sub3_answer\">Risposta 3 Domanda 2</label><input type=\"text\" name=\"q915616:2_sub3_answer\" id=\"q915616:2_sub3_answer\" size=\"10\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : ******head\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>);\nreturn p;\n}",
        "answer": "- parte 1: v+1 (vai alla prossima cella dell'array)\n- parte 2: n-1 (array di piu` corto di 1)\n- parte 3: head (la lista e` sempre la stessa)",
        "maxPoints": 3,
        "type": "multianswer"
      },
      {
        "number": 3,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915616:3_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 2 min]</b>\nSi consideri il seguente frammento di codice C:\nchar v[5] = {3,5,7};\nchar * p;\np = v+1;\nSi dica quale e` il valore delle seguenti espressioni,\nsizeof(v) <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:3_sub1_answer\">Risposta 1 Domanda 3</label><input type=\"text\" name=\"q915616:3_sub1_answer\" id=\"q915616:3_sub1_answer\" size=\"19\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : ****************5\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>\np[1]      <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:3_sub2_answer\">Risposta 2 Domanda 3</label><input type=\"text\" name=\"q915616:3_sub2_answer\" id=\"q915616:3_sub2_answer\" size=\"18\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : ****************7\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>",
        "answer": "- sizeof(v): 5\n- p[1]: 7",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 4,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915616:4_:sequencecheck\" value=\"2\"><b>[TEMPO STIMATO: 1 min]</b>\nSi definisca correttamente la seguente macro\n#define   STAMPA_CIAO      <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:4_sub1_answer\">Risposta 1 Domanda 4</label><input type=\"text\" name=\"q915616:4_sub1_answer\" id=\"q915616:4_sub1_answer\" size=\"17\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : printf(\"ciao\");\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>\nin modo tale che la seguente riga di codice stampi la stringa \"ciao\"\nSTAMPA_CIAO;",
        "answer": "printf(\"ciao\");\noppure anche\nprintf(\"ciao\\n\");",
        "maxPoints": 1,
        "type": "multianswer"
      },
      {
        "number": 5,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915616:5_:sequencecheck\" value=\"2\">\n<b>[TEMPO STIMATO: 3 min]</b>\nSiano date le seguenti definizioni di tipo e di strutture C:\n#include \"date.h\" /* contiene la definizione del tipo date */\n#include \"time.h\" /* contiene la definizione del tipo time */\ntypedef struct {\n&nbsp;&nbsp; unsigned int n;\n&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sn[10]; &nbsp;\n} sample;\nstruct node {\n&nbsp;&nbsp; date&nbsp;&nbsp; d;\n&nbsp;&nbsp; time&nbsp;&nbsp; t;\n&nbsp;&nbsp; sample s;&nbsp; &nbsp;\n&nbsp;&nbsp; struct node *next;\n};\nSia item così definita:\nstruct node item;\nNelle\nseguenti definizioni con inizializzazione specificare il tipo corretto\ndelle variabili a e t1 affinché siano compatibili con il tipo del valore sulla\ndestra dell'operatore di assegnamento.\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:5_sub1_answer\">Risposta 1 Domanda 5</label><input type=\"text\" name=\"q915616:5_sub1_answer\" id=\"q915616:5_sub1_answer\" size=\"6\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è :\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> a = item.s.sn;\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915616:5_sub2_answer\">Risposta 2 Domanda 5</label><input type=\"text\" name=\"q915616:5_sub2_answer\" id=\"q915616:5_sub2_answer\" size=\"6\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è :\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> &nbsp;t1 = &item.t;",
        "answer": "- parte 1: char *\n- parte 2: time *",
        "maxPoints": 2,
        "type": "multianswer"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "2020-07-02",
    "date": "2020.07.02",
    "course": "A",
    "title": "2020.07.02 Prova di C da remoto",
    "questions": [
      {
        "number": 3,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915620:3_:sequencecheck\" value=\"2\"><h4 style=\"text-align: left;\"></h4><h4>[tempo stimato: 5 min (esercizio corrente), 7 min (prossimi esercizi)]</h4><p style=\"text-align: left;\">Una lista C e` definita attraverso le seguenti struct node e list.\n<div style=\"text-align: left;\">typedef struct node {\nint value;\nstruct node * next;\n} node;\ntypedef node* list;\n</div><p style=\"text-align: left;\">La seguente funzione elimina e dealloca gli elementi della lista in <b>posizione pari</b>, tenendo conto che l'elemento di testa è considerato in posizione 1, il seguente in posizione 2, etc.\n<p style=\"text-align: left;\"><b>Completare il codice della funzione avendo l'accortezza di non inserire spazi bianchi non necessari.</b>\n<div style=\"text-align: left;\"><span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:3_sub1_answer\">Risposta 1 Domanda 3</label><input type=\"text\" name=\"q915620:3_sub1_answer\" id=\"q915620:3_sub1_answer\" size=\"4\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : list\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> list_elimina_pos_pari(list head) {\nlist tmp;\nif (head == NULL || head->next == NULL)\nreturn head;\ntmp = head->next;\nhead->next = list_elimina_pos_pari(<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:3_sub2_answer\">Risposta 2 Domanda 3</label><input type=\"text\" name=\"q915620:3_sub2_answer\" id=\"q915620:3_sub2_answer\" size=\"16\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : head-&gt;next-&gt;next\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>);\nfree(<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:3_sub3_answer\">Risposta 3 Domanda 3</label><input type=\"text\" name=\"q915620:3_sub3_answer\" id=\"q915620:3_sub3_answer\" size=\"3\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : tmp\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>);\nreturn <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:3_sub4_answer\">Risposta 4 Domanda 3</label><input type=\"text\" name=\"q915620:3_sub4_answer\" id=\"q915620:3_sub4_answer\" size=\"4\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : head\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>;\n}\n</div>",
        "answer": "Risposta 1: list\nRisposta 2: head->next->next\nRisposta 3: tmp\nRisposta 4: head",
        "maxPoints": 4,
        "type": "multianswer"
      },
      {
        "number": 4,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915620:4_:sequencecheck\" value=\"2\"><h4>[tempo stimato: 4 min (esercizio corrente), 3 min (prossimi esercizi)]</h4>Completare il seguente codice in cui viene cercato l'elemento minimo di un array.\n<b>Completare il codice  avendo l'accortezza di non inserire spazi bianchi non necessari.</b>\n#include <stdio.h>\nvoid find_min(const double * v, const int size, double * min) {\nint i;\nif (size <= 0 || v==NULL) {\nfprintf(stderr, \"Parametri di input errati\\n\");\nreturn;\n}\n*min = <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:4_sub1_answer\">Risposta 1 Domanda 4</label><input type=\"text\" name=\"q915620:4_sub1_answer\" id=\"q915620:4_sub1_answer\" size=\"4\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : v[0]\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>;\nfor (i=1; i<size; i++) {\nif (v[i] < *min)\n*min = v[i];\n}\n}\nint main() {\ndouble v[]={3.1, -5.1, -1};\ndouble min;\nfind_min(v, sizeof(v)/sizeof(v[0]), <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915620:4_sub2_answer\">Risposta 2 Domanda 4</label><input type=\"text\" name=\"q915620:4_sub2_answer\" id=\"q915620:4_sub2_answer\" size=\"4\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : &amp;min\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>);\nprintf(\"Il minimo e` :%f\\n\", min);\n}",
        "answer": "Risposta 1: v[0]\nRisposta 2: &min",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 5,
        "text": "<b>[tempo stimato: 3 min]</b>\nQuale valore viene stampato dall'esecuzione del seguente codice?\n(aggiungere eventuali altre considerazioni nella risposta)\n#include <stdio.h><stdio.h>\ndouble find_max(const double * v) {\nint i;\ndouble max;\nif (v==NULL) {\nfprintf(stderr, \"Array vuoto\\n\");\nreturn -1;\n}\nmax = v[0];\nfor (i=1; i<sizeof(v); i++) {\nif (v[i] > max)\nmax = v[i];\n}\n<sizeof(v); i++)=\"\" {=\"\" if=\"\" (v[i]=\"\">  return max;\n}\nint main() {\ndouble v[] = {1,2,3,4,5,6,7,8,9,10,11,12};\nprintf(\"Il massimo e` %f\\n\", find_max(v));\n}\n</sizeof(v);></stdio.h>",
        "answer": "Risposta: 8 (se i puntatori sono rappresentati su 8 byte)\nDifatti il for della funzione find_max cerca il massimo fino a sizeof(v) che NON e` la dimensione dell'array, ma e` la dimensione del puntatore.\nDi questo ce ne dobbiamo accorgere subito perche' in C una funzione a cui viene passato un puntatore NON PUO` sapere la dimensione dell'array puntato.",
        "maxPoints": 2,
        "type": "essay"
      }
    ],
    "topics": [
      "file-system"
    ]
  },
  {
    "id": "2020-06-08",
    "date": "2020.06.08",
    "course": "A",
    "title": "2020.06.08 Prova di C da remoto",
    "questions": [
      {
        "number": 4,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915624:4_:sequencecheck\" value=\"2\"><h4> [tempo stimato: 3 min]</h4>Completare il codice C sottostante, considerando che la funzione slength\nrestituisce la lunghezza in caratteri della stringa C passata per\nriferimento. <b>Non inserire spazi bianchi non necessari nelle risposte.</b>\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915624:4_sub1_answer\">Risposta 1 Domanda 4</label><input type=\"text\" name=\"q915624:4_sub1_answer\" id=\"q915624:4_sub1_answer\" size=\"4\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : int\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> &nbsp;slength(char *s){\n&nbsp;&nbsp;&nbsp; int n=0;\n&nbsp;&nbsp;&nbsp; while ( *s++!='\\0' )\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915624:4_sub2_answer\">Risposta 2 Domanda 4</label><input type=\"text\" name=\"q915624:4_sub2_answer\" id=\"q915624:4_sub2_answer\" size=\"5\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : n+=1\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> ;\n&nbsp;&nbsp;&nbsp; return n;\n}",
        "answer": "Risposta 1: int\nRisposta 2: n++",
        "maxPoints": 2,
        "type": "multianswer"
      },
      {
        "number": 5,
        "text": "<h4 class=\"accesshide\">Testo della domanda</h4><input type=\"hidden\" name=\"q915624:5_:sequencecheck\" value=\"2\"><h4>[tempo stimato: 5 min]</h4>La seguente funzione C 'list_alloc' alloca&nbsp; in memoria dinamica una\nlista di n elementi di tipo 'node', tipo&nbsp; definito secondo la seguente\nstruttura:\ntypedef struct _node { double *val;\nstruct _node *next;\n} node;\nGli 'n' elementi della lista sono allocati in una struttura ad array.\nLa\nfunzione restituisce il puntatore alla testa della lista così allocata,\nNULL nel caso l'allocazione non è potuta essere soddisfatta dal sistema\noperativo.\n<b>Completare il codice della funzione avendo l'accortezza di non inserire spazi bianchi non necessari.</b>\n<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915624:5_sub1_answer\">Risposta 1 Domanda 5</label><input type=\"text\" name=\"q915624:5_sub1_answer\" id=\"q915624:5_sub1_answer\" size=\"6\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : node*\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> list_alloc(int n){\n&nbsp;&nbsp;&nbsp;&nbsp; int i;\n&nbsp;&nbsp;&nbsp;&nbsp; node *head=NULL;\n&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp; head = (node *)calloc(n,<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915624:5_sub2_answer\">Risposta 2 Domanda 5</label><input type=\"text\" name=\"q915624:5_sub2_answer\" id=\"q915624:5_sub2_answer\" size=\"12\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : sizeof(node)\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span> );&nbsp; // alloca array di n nodi\n&nbsp;&nbsp; &nbsp; if (head!=NULL){\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *item&nbsp;&nbsp;&nbsp;&nbsp; = head;\n&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; const node *end_list = head+n-1;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( item=head ; item < end_list ; item++)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"subquestion form-inline d-inline\"><label class=\"subq accesshide\" for=\"q915624:5_sub3_answer\">Risposta 3 Domanda 5</label><input type=\"text\" name=\"q915624:5_sub3_answer\" id=\"q915624:5_sub3_answer\" size=\"19\" class=\"form-control mb-1 incorrect\" readonly=\"readonly\"><a role=\"button\" tabindex=\"0\" class=\"feedbacktrigger btn btn-link p-0\" data-toggle=\"popover\" data-container=\"body\" data-content=\"<span class=\"feedbackspan\">Risposta non data\nLa risposta corretta è : item-&gt;next=item+1\nPunteggio ottenuto 0 su 1</span>\" data-placement=\"right\" data-trigger=\"hover focus\" data-html=\"true\" href=\"#\"><i class=\"icon fa fa-remove text-danger fa-fw \" title=\"Risposta errata\" role=\"img\" aria-label=\"Risposta errata\"></i></a></span>;   // imposta il campo next a puntare al nodo successivo\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n&nbsp;&nbsp; &nbsp; }\n&nbsp;&nbsp;&nbsp;&nbsp; return head;\n}",
        "answer": "Risposta 1: node *\nRisposta 2: sizeof(node)\nRisposta 3: item->next=item+1",
        "maxPoints": 3,
        "type": "multianswer"
      }
    ],
    "topics": [
      "file-system",
      "memoria-primaria"
    ]
  }
]